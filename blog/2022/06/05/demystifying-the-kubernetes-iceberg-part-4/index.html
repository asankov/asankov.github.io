<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.100.1"><link rel=canonical href=https://asankov.dev/blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Demystifying the Kubernetes Iceberg: Part 4 | Anton Sankov's Blog</title><meta name=description content="Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This series of articles explains all the concepts listed in the &#34;Kubernetes Iceberg&#34; diagram by Flant.
"><meta property="og:title" content="Demystifying the Kubernetes Iceberg: Part 4"><meta property="og:description" content="Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This series of articles explains all the concepts listed in the &#34;Kubernetes Iceberg&#34; diagram by Flant.
"><meta property="og:type" content="article"><meta property="og:url" content="https://asankov.dev/blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-06-05T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-06T11:19:07+03:00"><meta property="og:site_name" content="Anton Sankov's Blog"><meta itemprop=name content="Demystifying the Kubernetes Iceberg: Part 4"><meta itemprop=description content="Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This series of articles explains all the concepts listed in the &#34;Kubernetes Iceberg&#34; diagram by Flant.
"><meta itemprop=datePublished content="2022-06-05T00:00:00+00:00"><meta itemprop=dateModified content="2022-06-06T11:19:07+03:00"><meta itemprop=wordCount content="2789"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Demystifying the Kubernetes Iceberg: Part 4"><meta name=twitter:description content="Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This series of articles explains all the concepts listed in the &#34;Kubernetes Iceberg&#34; diagram by Flant.
"><link rel=preload href=/scss/main.min.44a19d8ca81d4539a8082ac72051abbde416454636e4b104766b793a69508550.css as=style><link href=/scss/main.min.44a19d8ca81d4539a8082ac72051abbde416454636e4b104766b793a69508550.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7Y9WXX1393"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-7Y9WXX1393',{anonymize_ip:!1})}</script></head><body class="td-page td-blog"><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" style=position:relative><a class=navbar-brand href=/><span class=navbar-logo></span><span class="text-uppercase font-weight-bold text-nord5">Anton Sankov's Blog</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class="nav-link active" href=/blog/><span class=active>Blog</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/about/><span>About Me</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><form class="td-sidebar__search d-flex align-items-center"><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type=button data-toggle=collapse data-target=#td-section-nav aria-controls=td-docs-nav aria-expanded=false aria-label="Toggle section navigation"></button></form><nav class="collapse td-sidebar-nav" id=td-section-nav><ul class="td-sidebar-nav__section pr-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-blog-li><a href=/blog/ title="Anton Sankov's Blog" class="align-left pl-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-blog><span>Blog</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-blog20220605demystifying-the-kubernetes-iceberg-part-4-li><a href=/blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/ class="align-left pl-0 active td-sidebar-link td-sidebar-link__page" id=m-blog20220605demystifying-the-kubernetes-iceberg-part-4><span class=td-sidebar-nav-active-item>Demystifying the Kubernetes Iceberg: Part 4</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-blog20220529demystifying-the-kubernetes-iceberg-part-3-li><a href=/blog/2022/05/29/demystifying-the-kubernetes-iceberg-part-3/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-blog20220529demystifying-the-kubernetes-iceberg-part-3><span>Demystifying the Kubernetes Iceberg: Part 3</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-blog20220522demystifying-the-kubernetes-iceberg-part-2-li><a href=/blog/2022/05/22/demystifying-the-kubernetes-iceberg-part-2/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-blog20220522demystifying-the-kubernetes-iceberg-part-2><span>Demystifying the Kubernetes Iceberg: Part 2</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-blog20220515demystifying-the-kubernetes-iceberg-part-1-li><a href=/blog/2022/05/15/demystifying-the-kubernetes-iceberg-part-1/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-blog20220515demystifying-the-kubernetes-iceberg-part-1><span>Demystifying the Kubernetes Iceberg: Part 1</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-blog20220421securing-kubernetes-with-open-policy-agent-li><a href=/blog/2022/04/21/securing-kubernetes-with-open-policy-agent/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-blog20220421securing-kubernetes-with-open-policy-agent><span>Securing Kubernetes with Open Policy Agent</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-blog20220129different-ways-to-initialize-go-structs-li><a href=/blog/2022/01/29/different-ways-to-initialize-go-structs/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-blog20220129different-ways-to-initialize-go-structs><span>Different Ways to Initialize Go structs</span></a></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ml-2 pb-1 pt-2 mb-0"></div><div class=td-toc><nav id=TableOfContents><ul><li><a href=#tier-5-part-1---security>Tier 5, Part 1 - Security</a><ul><li><a href=#rbac>RBAC</a></li><li><a href=#podsecuritypolicy>PodSecurityPolicy</a></li><li><a href=#audit-logging>Audit logging</a></li><li><a href=#image-validation-and-signing>Image validation and signing</a></li><li><a href=#seccomp>seccomp</a></li><li><a href=#apparmor>AppArmor</a></li><li><a href=#networkpolicy>NetworkPolicy</a></li><li><a href=#mutating-and-admission-webhooks>Mutating and Admission webhooks</a></li><li><a href=#dynamic-admission-control>Dynamic Admission Control</a></li><li><a href=#open-policy-agent>Open Policy Agent</a></li><li><a href=#bonus-gatekeeper>Bonus: Gatekeeper</a></li><li><a href=#openid-connect>OpenID Connect</a></li><li><a href=#dex>Dex</a></li><li><a href=#enterprise-level-security>Enterprise-level security</a></li></ul></li><li><a href=#summary>Summary</a></li></ul></nav></div><div class="taxonomy taxonomy-terms-cloud taxo-categories"><h5 class=taxonomy-title>Categories</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://asankov.dev/categories/gatekeeper/ data-taxonomy-term=gatekeeper><span class=taxonomy-label>Gatekeeper</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://asankov.dev/categories/go/ data-taxonomy-term=go><span class=taxonomy-label>Go</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://asankov.dev/categories/kubernetes/ data-taxonomy-term=kubernetes><span class=taxonomy-label>Kubernetes</span><span class=taxonomy-count>5</span></a></li><li><a class=taxonomy-term href=https://asankov.dev/categories/open-policy-agent/ data-taxonomy-term=open-policy-agent><span class=taxonomy-label>Open Policy Agent</span><span class=taxonomy-count>1</span></a></li><li><a class=taxonomy-term href=https://asankov.dev/categories/security/ data-taxonomy-term=security><span class=taxonomy-label>Security</span><span class=taxonomy-count>2</span></a></li></ul></div></aside><main class="col-12 col-md-9 col-xl-8 pl-md-5 pr-md-4" role=main><div class=td-content><h1>Demystifying the Kubernetes Iceberg: Part 4</h1><div class=lead>Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This series of articles explains all the concepts listed in the &ldquo;Kubernetes Iceberg&rdquo; diagram by Flant.</div><div class="td-byline mb-4"><time datetime=2022-06-05 class=text-muted>Sunday, June 05, 2022</time></div><header class=article-meta><div class="taxonomy taxonomy-terms-article taxo-categories"><h5 class=taxonomy-title>Categories:</h5><ul class=taxonomy-terms><li><a class=taxonomy-term href=https://asankov.dev/categories/kubernetes/ data-taxonomy-term=kubernetes><span class=taxonomy-label>Kubernetes</span></a></li><li><a class=taxonomy-term href=https://asankov.dev/categories/security/ data-taxonomy-term=security><span class=taxonomy-label>Security</span></a></li></ul></div><p class=reading-time><i class="fa fa-clock" aria-hidden=true></i>&nbsp; 14 minute read &nbsp;</p></header><p>This is the fourth article of the &ldquo;Demystifying the Kubernetes Iceberg&rdquo; series.
My goal for this series is to explain all concepts mentioned in the “Kubernetes Iceberg” diagram by <a href=https://flant.com/>Flant</a>.</p><p>In this article, we will dive into Tier 5 of the iceberg.
Since this tier is huge and would produce a really long article, I decided to split it in two parts.</p><p>The first part (this article) will focus on all the security related concepts in this tier, the second one will focus on everything else.</p><p>You can find the others article:</p><ul><li><a href=/blog/2022/05/15/demystifying-the-kubernetes-iceberg-part-1/>Part 1</a></li><li><a href=/blog/2022/05/22/demystifying-the-kubernetes-iceberg-part-2/>Part 2</a></li><li><a href=/blog/2022/05/22/demystifying-the-kubernetes-iceberg-part-3/>Part 3</a></li></ul><p>I will publish one article each week until I complete the whole iceberg.</p><h2 id=tier-5-part-1---security>Tier 5, Part 1 - Security</h2><h3 id=rbac>RBAC</h3><p>RBAC stands for Role-Based Access Control.</p><p>It is a way of doing authorization by having a set of Roles.
Each Role is assigned a set of Permissions (ability to do something).
Each user in the system is assigned a set of Roles.
In the end, the Roles a user has assigned govern how much they can do in the system.</p><p>The permissions assigned to the roles contain a Kubernetes object and a verb.
For example, some Roles can be allowed to <code>List Deployment</code> but not to <code>Create Deployments</code> or <code>Update Deployments</code>.</p><p>RBAC is the primary way for Kubernetes to do authorization.</p><p>RBAC in Kubernetes can be configured dynamically through 4 API objects - <code>Role</code>, <code>ClusterRole</code>, <code>RoleBinding</code>, and <code>ClusterRoleBinding</code>.</p><p>A sample RBAC scheme in an organization can look like this:</p><table><thead><tr><th>Role</th><th>Get/List Deployments</th><th>Create/Update Deployments</th><th>Create RoleBinding</th></tr></thead><tbody><tr><td>Developer</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>DevOps</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>Admin</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><p>A user with the <code>Developer</code> role can view the Deployments into the cluster, but they cannot edit them or create new ones.</p><p>The <code>DevOps</code> role can not only view the Deployments but also create new ones and update existing ones.</p><p>However, neither the <code>DevOps</code> nor the <code>Developer</code> can create new <code>RoleBindings</code> (which would mean assigning new roles to users, hence giving more permissions to some users).
This action can only be performed by the <code>Admin</code> group.</p><p>You can read about RBAC in Kubernetes <a href=https://kubernetes.io/docs/reference/access-authn-authz/rbac/>here</a>.</p><p>RBAC is good because it gives you a lot of flexibility when assigning Roles and Permissions.
However, RBAC alone may not be enough to protect your cluster.
Continue reading for more advanced security techniques used in Kubernetes.</p><h3 id=podsecuritypolicy>PodSecurityPolicy</h3><p><code>PodSecurityPolicy</code> is a (deprecated) Kubernetes object that enabled (some sort of) fine-grained authorization of pod creation and updates.</p><p>When creating a <code>PodSecurityPolicy</code>, you can specify some set of predefined rules that will be enforced for your Pod objects.</p><p>For example, the following <code>PodSecurityPolicy</code> denies <code>Pods</code> that run privileged containers:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>apiVersion</span>: policy/v1beta1
</span></span><span style=display:flex><span><span style=color:#268bd2>kind</span>: PodSecurityPolicy
</span></span><span style=display:flex><span><span style=color:#268bd2>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#268bd2>name</span>: example
</span></span><span style=display:flex><span><span style=color:#268bd2>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#268bd2>privileged</span>: <span style=color:#cb4b16>false</span> <span style=color:#586e75># Don&#39;t allow privileged pods!</span>
</span></span><span style=display:flex><span>  <span style=color:#586e75># The rest fills in some required fields.</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>seLinux</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>rule</span>: RunAsAny
</span></span><span style=display:flex><span>  <span style=color:#268bd2>supplementalGroups</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>rule</span>: RunAsAny
</span></span><span style=display:flex><span>  <span style=color:#268bd2>runAsUser</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>rule</span>: RunAsAny
</span></span><span style=display:flex><span>  <span style=color:#268bd2>fsGroup</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>rule</span>: RunAsAny
</span></span><span style=display:flex><span>  <span style=color:#268bd2>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#2aa198>&#34;*&#34;</span>
</span></span></code></pre></div><p>When we try to create a Pod that defies this rule, we will get an error similar to this one:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Error from server (Forbidden): error when creating &#34;STDIN&#34;: pods &#34;privileged&#34; is forbidden: unable to validate against any pod security policy: [spec.containers[0].securityContext.privileged: Invalid value: true: Privileged containers are not allowed]
</span></span></code></pre></div><p>These rules are enforced by an admission controller that needs to be activated before we can create and enforce any <code>PodSecurityPolicies</code>.</p><p>For the full spec of available rules, check out the <a href=https://kubernetes.io/docs/concepts/security/pod-security-policy/#what-is-a-pod-security-policy>docs</a>.</p><h4 id=deprecation-notice>Deprecation notice</h4><p><code>PodSecurityPolicies</code> are deprecated since Kubernetes v1.21 and will be removed in v1.25.
Those using <code>PodSecurityPolicies</code> should migrate to <code>[PodSecurityStandards](https://kubernetes.io/docs/concepts/security/pod-security-standards/)</code> which is a new and more flexible alternative to <code>PodSecurityPolicies</code></p><h3 id=audit-logging>Audit logging</h3><p>Audit logging is a special kind of logging that aims to show who accessed what in a system.
Audit logs are treated very cautiously, usually outsourced to an external system, so that even if something fails with our application, the audit logs are saved and can be viewed.
This also prevents an attacker that got into our system from messing up with our audit logs and deleting its trails.</p><p>Kubernetes provides audit logging functionality that logs every access to the given Kubernetes resources.
One could configure audit logging at a different level for the different kinds of resources.
For example, you could want to log absolutely everything when it comes to the critical resources but log less information when it comes to non-critical resources.</p><p>Audit logging is configured via the <code>Policy</code> object in the <code>audit.k8s.io</code> APi group.</p><p>For example, this <code>Policy</code> object configures the api server to log every request and response when it comes to interaction with <code>Pods</code> and to log nothing when it comes to interaction with the <code>"controller-leader"</code> <code>ConfigMap</code>:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>apiVersion</span>: audit.k8s.io/v1
</span></span><span style=display:flex><span><span style=color:#268bd2>kind</span>: Policy
</span></span><span style=display:flex><span><span style=color:#268bd2>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#268bd2>level</span>: RequestResponse
</span></span><span style=display:flex><span>    <span style=color:#268bd2>resources</span>:
</span></span><span style=display:flex><span>      - <span style=color:#268bd2>group</span>: <span style=color:#2aa198>&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>resources</span>: [<span style=color:#2aa198>&#34;pods&#34;</span>]
</span></span><span style=display:flex><span>  - <span style=color:#268bd2>level</span>: None
</span></span><span style=display:flex><span>    <span style=color:#268bd2>resources</span>:
</span></span><span style=display:flex><span>      - <span style=color:#268bd2>group</span>: <span style=color:#2aa198>&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>resources</span>: [<span style=color:#2aa198>&#34;configmaps&#34;</span>]
</span></span><span style=display:flex><span>        <span style=color:#268bd2>resourceNames</span>: [<span style=color:#2aa198>&#34;controller-leader&#34;</span>]
</span></span></code></pre></div><h4 id=audit-logging-backends>Audit logging backends</h4><p>The Kube API server supports two audit logging backends.</p><p>The first one is <strong>file</strong>-based.
Using it means that the API server will output all audit logs to a file.
It is configured via the <code>--audit-log-path</code> flag.</p><p>The second supported backend is a <strong>webhooks</strong>-based one.
Using it means that the API server will call an external API to save the audit logs.
It is configured via the <code>--audit-webhook-config-file</code> flag.
The value of the flag should be the name of a kubeconfig file that specifies the location of the remote server and the credentials to access it.
The remote server should be a form of the Kubernetes API.</p><h3 id=image-validation-and-signing>Image validation and signing</h3><p>Signing container images means that the contents of a particular container image version are cryptographically signed, and they can be later verified.
This increases the trust in downloading container images from the internet because you have a way to verify that what you have downloaded is exactly what you expect.</p><p>This can be done manually, but people often automate it and implement the workflow in their CI pipelines.</p><p>The most popular project that enables this workflow is <a href=https://github.com/sigstore/cosign>cosign</a>.</p><h3 id=seccomp>seccomp</h3><p><a href=https://lwn.net/Articles/656307/><code>seccomp</code></a> (short for secure computing mode) is a Linux kernel utility that, when activated for a process, restricts the process to making any system calls (except <code>exit()</code>, <code>sigreturn()</code>, <code>read()</code>, and <code>write()</code> to already open file descriptors).</p><p>Kubernetes supports enabling seccomp profiles to the containers running in the Pods.</p><p>This is done via the <code>spec.securityContext.seccompProfile</code> in the Pod spec.</p><p>There are different seccomp profiles that provide various levels of restriction.
You don&rsquo;t want to allow a container to do many syscalls, but you also don&rsquo;t want to obstruct the container from doing its job by restricting it from making the necessary syscalls.
That is why it&rsquo;s essential to craft your custom seccomp profiles that give a container permission to do only the syscalls that it is supposed to be doing.</p><h3 id=apparmor>AppArmor</h3><p><a href=https://apparmor.net/>AppArmor</a> is a Linux application security system.
It is deployed as a Kernel module, and most Linux distributions ship with AppArmor enabled.</p><p>It is used by enabling certain profiles that protect your OS from known harmful and malicious behavior of applications.</p><p>It is also integrated into Kubernetes.
You can enable it with kubelet flags and assign AppArmor profiles to containers via annotations.</p><p>For example, creating a Pod with this annotation will enable the <code>runtime/default</code> AppArmor profile for the specified containers:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>container.apparmor.security.beta.kubernetes.io/&lt;container_name&gt;</span>: runtime/default
</span></span></code></pre></div><p>You can also register custom profiles.
This profile will enable file writes for all containers that have it assigned to them:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;tunables/global&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span>profile k8s<span style=color:#719e07>-</span>apparmor<span style=color:#719e07>-</span>example<span style=color:#719e07>-</span>deny<span style=color:#719e07>-</span>write flags<span style=color:#719e07>=</span>(attach_disconnected) {
</span></span><span style=display:flex><span>  <span style=color:#719e07>#include</span> <span style=color:#719e07>&lt;abstractions/base&gt;</span><span style=color:#719e07>
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span>  file,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#719e07># Deny all file writes.
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>  deny <span style=color:#586e75>/** w,
</span></span></span><span style=display:flex><span><span style=color:#586e75>}
</span></span></span></code></pre></div><p>You can assign it to a container via this annotation:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>container.apparmor.security.beta.kubernetes.io/&lt;container_name&gt;</span>: k8s-apparmor-example-deny-write
</span></span></code></pre></div><p>This is the same annotation as the previous one.
We just changed the profile name to match the name of our custom profile.</p><p>If we create a container with this AppArmor profile and try to write to a file, we will get the following error:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ touch /tmp/test
</span></span><span style=display:flex><span>touch: /tmp/test: Permission denied
</span></span><span style=display:flex><span>error: error executing remote command: <span style=color:#b58900>command</span> terminated with non-zero <span style=color:#b58900>exit</span> code: Error executing in Docker Container: <span style=color:#2aa198>1</span>
</span></span></code></pre></div><p>AppArmor has been a Kubernetes feature since v1.4, but it&rsquo;s still in beta.
That is why it is configured via annotations and not first-class spec fields.</p><h3 id=networkpolicy>NetworkPolicy</h3><p><code>NetworkPolicy</code> is a Kubernetes resource that controls the allowed ingress and egress traffic from and to a <code>Pod</code>.</p><p><code>NetworkPolicy</code> is just a configuration resource.
It defines the allowed destinations but does not enforce anything.
To enforce the <code>NetworkPolicies</code>, you need to install a <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>network plugin (also called CNI plugin)</a>.
Applying a <code>NetworkPolicy</code> without installing a network plugin will have no effect.</p><p>When creating a <code>NetworkPolicy</code>, you define all allowed <code>ingress</code> and <code>egress</code> destinations.
The network plugin will block every destination that is not in this allowlist.
<code>NetworkPolicies</code> are additive.
If you have two network policies for the same Pod, the allowlist for this Pod is the sum of the allowlist of the two policies.
Therefore, if you have an allow-all <code>NetworkPolicy</code> for a <code>Pod</code>, all other policies for this <code>Pod</code> will be useless.</p><p>Here is an example policy applied to all pods with the label <code>role: db</code>.
It specifies that these Pods are allowed only ingress connections from pods with the label <code>role: frontend</code> and from the CIDR IP block <code>172.17.0.0/16</code> except for <code>172.17.1.0/24</code>:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>apiVersion</span>: networking.k8s.io/v1
</span></span><span style=display:flex><span><span style=color:#268bd2>kind</span>: NetworkPolicy
</span></span><span style=display:flex><span><span style=color:#268bd2>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#268bd2>name</span>: test-network-policy
</span></span><span style=display:flex><span>  <span style=color:#268bd2>namespace</span>: default
</span></span><span style=display:flex><span><span style=color:#268bd2>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#268bd2>podSelector</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#268bd2>role</span>: db
</span></span><span style=display:flex><span>  <span style=color:#268bd2>policyTypes</span>:
</span></span><span style=display:flex><span>    - Ingress
</span></span><span style=display:flex><span>  <span style=color:#268bd2>ingress</span>:
</span></span><span style=display:flex><span>    - <span style=color:#268bd2>from</span>:
</span></span><span style=display:flex><span>        - <span style=color:#268bd2>ipBlock</span>:
</span></span><span style=display:flex><span>            <span style=color:#268bd2>cidr</span>: <span style=color:#2aa198>172.17.0.0</span>/16
</span></span><span style=display:flex><span>            <span style=color:#268bd2>except</span>:
</span></span><span style=display:flex><span>              - <span style=color:#2aa198>172.17.1.0</span>/24
</span></span><span style=display:flex><span>        - <span style=color:#268bd2>podSelector</span>:
</span></span><span style=display:flex><span>            <span style=color:#268bd2>matchLabels</span>:
</span></span><span style=display:flex><span>              <span style=color:#268bd2>role</span>: frontend
</span></span></code></pre></div><h3 id=mutating-and-admission-webhooks>Mutating and Admission webhooks</h3><p>Mutating and Admission webhooks are powerful instruments.
Admission webhooks allow you to implement dynamic admission control.
Mutating webhooks enable you to implement dynamic remediation of resources being created/updated.</p><h4 id=admission-webhooks>Admission webhooks</h4><p>Admission webhooks are webhooks that determine whether a create/update/delete operation for a resource should be allowed.</p><p>They are called by the <code>ValidatingAdmissionWebhook</code> admission controller.
So although admission controllers themselves are not extendible, this particular admission controller allows you to deploy a webhook which will be called by Kubernetes, thus adding extensibility to the admission workflow.</p><p>An admission webhook is just that, a webhook.
It expects a specific request and should return a proper response.
In between, you can implement whatever logic you want.
This way, you can have full control over what resources are deployed into your cluster.</p><h4 id=mutating-webhooks>Mutating webhooks</h4><p>Mutating webhooks are webhooks that mutate a resource that is being applied to the API server.</p><p>They are called by the <code>ValidatingAdmissionWebhook</code> admission controller.</p><p>This can be useful to enforce a certain property of your resources.
For example, if you want to be sure that all your Pods will have their <code>spec.securityContext.runAsUser</code> field equal to <code>1000</code>, you can have a mutating webhook that will change this field to <code>1000</code> each time a <code>Pod</code> is applied.</p><p>NOTE: This example will only work for <code>Pods</code> that are applied directly to the API server, it will not work for ones owned by <code>Deployments</code> or <code>ReplicaSets</code>, because the Deployment controller will be reconciling the Pods not stop and trying to set the field to its original value.
If you want to achieve that, you will need to create separate mutating webhook for <code>Deployments</code>, <code>ReplicaSets</code>, etc.</p><h3 id=dynamic-admission-control>Dynamic Admission Control</h3><p>By default, Kubernetes ships with so-called admission controllers.
These are controllers that control the interaction with the Kubernetes resources (create/update/delete, etc.).</p><p>More specifically, they may block the creation/update/deletion of a given resource if that resource violates some rule according to the controller.</p><p>These controllers are in-tree.
Their codebase lives together with the Kubernetes codebase.
They are compiled along with Kubernetes and called natively.
If you want to add an admission controller, you need to change the Kubernetes source code, rebuild it and deploy your custom Kubernetes version.</p><p>Admission controllers can be enabled or disabled based on your preference.
For the complete list of available admission controllers, check the <a href=https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#experimenting-with-admission-webhooks>docs</a>.</p><h3 id=open-policy-agent>Open Policy Agent</h3><p>Open Policy Agent or OPA is a general-purpose policy engine.
It evaluates JSON input against a set of Rego policies and returns a JSON output.</p><p>A straightforward Rego policy:</p><pre tabindex=0><code class=language-rego data-lang=rego>package kubernetes

default allow = false

allow = true {
    input.author.name = &#34;Anton Sankov&#34;
}
</code></pre><p>A simple JSON input:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#268bd2>&#34;author&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#268bd2>&#34;name&#34;</span>: <span style=color:#2aa198>&#34;Anton Sankov&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The output of this JSON input evaluated against this policy:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#268bd2>&#34;allow&#34;</span>: <span style=color:#cb4b16>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It is general-purpose; therefore, it can be used for absolutely everything.</p><p>In the Kubernetes ecosystem, it is widely used for security, being the backbone of projects like Gatekeeper that provide customizable validating webhook.
In this case, the admission policies are written in Rego, and the Kubernetes object being evaluated is represented as JSON.</p><h3 id=bonus-gatekeeper>Bonus: Gatekeeper</h3><p>The Gatekeeper project is not included in the iceberg, but I think it&rsquo;s an important part of the Kubernetes ecosystem and steps on some concepts explained here, so I will include it in the article nonetheless.</p><p>Gatekeeper is a customizable admission webhooks.
It uses OPA under the hood and implement and admission webhook, so it can be used to implement dynamic admission control.</p><p>Since it uses OPA, the policies are written in Rego.
Gatekeeper is responsible for registering the webhook that Kubernetes will call when someone interacts with the resources.
These resource will be then passed to the policy as arguments, so that you can make decisions based on the resource field.</p><p>Policies are stored as CRD(Custom Resource Definition).
This CRD is also registered by Gatekeeper, to allow the users to interact with policies as first-class resources in a Kubernetes-native way.</p><p>To register a simple policy that will be evaluated by Gatekeeper you need to create these two resources:</p><p>First, a <code>ConstraintTemplate</code> that specifies the Rego policy and the expected arguments:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>apiVersion</span>: templates.gatekeeper.sh/v1
</span></span><span style=display:flex><span><span style=color:#268bd2>kind</span>: ConstraintTemplate
</span></span><span style=display:flex><span><span style=color:#268bd2>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#268bd2>name</span>: k8srequiredlabels
</span></span><span style=display:flex><span><span style=color:#268bd2>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#268bd2>crd</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#268bd2>names</span>:
</span></span><span style=display:flex><span>        <span style=color:#268bd2>kind</span>: K8sRequiredLabels
</span></span><span style=display:flex><span>      <span style=color:#268bd2>validation</span>:
</span></span><span style=display:flex><span>        <span style=color:#586e75># Schema for the `parameters` field</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>openAPIV3Schema</span>:
</span></span><span style=display:flex><span>          <span style=color:#268bd2>type</span>: object
</span></span><span style=display:flex><span>          <span style=color:#268bd2>properties</span>:
</span></span><span style=display:flex><span>            <span style=color:#268bd2>labels</span>:
</span></span><span style=display:flex><span>              <span style=color:#268bd2>type</span>: array
</span></span><span style=display:flex><span>              <span style=color:#268bd2>items</span>:
</span></span><span style=display:flex><span>                <span style=color:#268bd2>type</span>: string
</span></span><span style=display:flex><span>  <span style=color:#268bd2>targets</span>:
</span></span><span style=display:flex><span>    - <span style=color:#268bd2>target</span>: admission.k8s.gatekeeper.sh
</span></span><span style=display:flex><span>      <span style=color:#268bd2>rego</span>: |<span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        package k8srequiredlabels
</span></span></span><span style=display:flex><span><span style=color:#2aa198>
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        violation[{&#34;msg&#34;: msg, &#34;details&#34;: {&#34;missing_labels&#34;: missing}}] {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>          provided := {label | input.review.object.metadata.labels[label]}
</span></span></span><span style=display:flex><span><span style=color:#2aa198>          required := {label | label := input.parameters.labels[_]}
</span></span></span><span style=display:flex><span><span style=color:#2aa198>          missing := required - provided
</span></span></span><span style=display:flex><span><span style=color:#2aa198>          count(missing) &gt; 0
</span></span></span><span style=display:flex><span><span style=color:#2aa198>          msg := sprintf(&#34;you must provide labels: %v&#34;, [missing])
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        }</span>        
</span></span></code></pre></div><p>then an instance of the <code>ConstraintTemplate</code> (in this case <code>K8sRequiredLabels</code>) to tell Gatekeeper when to invoke this policy and with what arguments:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#268bd2>apiVersion</span>: constraints.gatekeeper.sh/v1beta1
</span></span><span style=display:flex><span><span style=color:#268bd2>kind</span>: K8sRequiredLabels
</span></span><span style=display:flex><span><span style=color:#268bd2>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#268bd2>name</span>: deployments-must-have-gk
</span></span><span style=display:flex><span><span style=color:#268bd2>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#268bd2>match</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>kinds</span>:
</span></span><span style=display:flex><span>      - <span style=color:#268bd2>apiGroups</span>: [<span style=color:#2aa198>&#34;*&#34;</span>]
</span></span><span style=display:flex><span>        <span style=color:#268bd2>kinds</span>: [“Deployments&#34;]
</span></span><span style=display:flex><span>  <span style=color:#268bd2>parameters</span>:
</span></span><span style=display:flex><span>    <span style=color:#268bd2>labels</span>: [<span style=color:#2aa198>&#34;gatekeeper&#34;</span>]
</span></span></code></pre></div><p>If you want to learn more about using Gatekeeper and OPA check out my article about <a href=https://asankov.dev/blog/2022/04/21/securing-kubernetes-with-open-policy-agent/>Securing Kubernetes with Open Policy Agent</a>.</p><h3 id=openid-connect>OpenID Connect</h3><p><a href=https://openid.net/connect/>OpenID Connect</a> is a simple identity layer on top of the OAuth 2.0 protocol.
It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner.</p><h3 id=dex>Dex</h3><p><a href=https://dexidp.io/>Dex</a> is an <a href=https://dexidp.io/>OpenID Connect</a> provider.
It is an open-source project, currently a CNCF sandbox.</p><p>It provides a single interface for multiple authentication providers.</p><p>In the context of Kubernetes, Dex can be used as an authenticator plugin.
This means that users managed by other identity providers can automatically get some access to a Kubernetes cluster via Dex.</p><p>This is useful for bigger organizations, where users are managed in a centralized place like Active Directory.
An adapter like Dex could enable users being added to a company&rsquo;s AD (or other IDP) to automatically get access to all the relevant Kubernetes clusters that their other team members also have access to.</p><h3 id=enterprise-level-security>Enterprise-level security</h3><p>Enterprise-level security is a broad term and can mean a lot of things.
Every concept in this article can be part of an &ldquo;enterprise-level security.&rdquo;</p><p>An enterprise using Kubernetes and wanting to secure it in an &ldquo;enterprise&rdquo; way needs to use at least half of the things described in this article.</p><p>At a minimum, they need to use <a href=/blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4#RBAC>RBAC</a> to ensure that everyone has access only to the resource they need to have.
Ideally, that will be integrated with their AD provider using an <a href=/blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/#openid-connect>OpenID Connect</a> provider like <a href=/blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/#dex>Dex</a>.
Then, they need to enable <a href=/blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/#audit-logging>audit logging</a> so that if someone manages to escalate privileges or if RBAC is configured wrong, there is a reliable trace for that.</p><p>Another good additional layer of security would be to limit what processes the Pods can run via tools like <a href=blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/#apparmor>AppArmor</a> and <a href=blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/#seccomp>seccomp</a> and what network connections they can do via <a href=blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/#podsecuritypolicy>PodSecurityPolicies</a>.</p><p>Last but not least, they could implement Dynamic admission control via mutating and admission webhooks, using tools like <a href=blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/#open-policy-agent>OPA</a> and <a href=blog/2022/06/05/demystifying-the-kubernetes-iceberg-part-4/#gatekeeper>Gatekeeper</a>.</p><h2 id=summary>Summary</h2><p>This is all for part four.</p><p>In this article, we managed to go over many of the main Kubernetes security concepts.
Security is a really important topic in today&rsquo;s world and I believe that every Kubernetes practitioner should know at least a little bit of security.
I hope that this article can be a good starting point of someone getting into Kubernetes security.</p><p>I will publish the next article one week from now (13 June 2022).</p><p>If you don’t want to miss it, you can follow me on <a href=https://twitter.com/a_sankov>Twitter</a> or <a href=https://www.linkedin.com/in/asankov/>LinkedIn</a>.</p><ul class="list-unstyled d-flex justify-content-between align-items-center mb-0 pt-5"><li><a href=/blog/2022/05/29/demystifying-the-kubernetes-iceberg-part-3/ aria-label="Previous - Demystifying the Kubernetes Iceberg: Part 3" class="btn btn-primary"><span class=mr-1>←</span>Previous</a></li><a class="btn btn-primary disabled">Next<span class=ml-1>→</span></a></li></ul></div></main></div></div><footer class="py-5 row d-print-none bg-nord0"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank rel=noopener href=mailto:asankov96@gmail.com aria-label="User mailing list"><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank rel=noopener href=https://twitter.com/a_sankov aria-label=Twitter><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/asankov aria-label=GitHub><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=LinkedIn aria-label=LinkedIn><a class=text-white target=_blank rel=noopener href=https://linkedin.com/in/asankov aria-label=LinkedIn><i class="fab fa-linkedin"></i></a></li></ul></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 Anton Sankov All Rights Reserved</small>
<small class=ml-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></small><p class=mt-2><a href=/about/>About Me</a></p></div></div></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA==" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script>
<script src=/js/main.min.f38626bad45782a5e3683670d0d0c074576714550538f4bbc0458926df8f56fc.js integrity="sha256-84YmutRXgqXjaDZw0NDAdFdnFFUFOPS7wEWJJt+PVvw=" crossorigin=anonymous></script></body></html>