
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Demystifying the Kubernetes Iceberg: Part 1</title>
    <meta name="description" content="Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This article explains all the concepts listed in the "Kubernetes Iceberg" meme from Reddit." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://asankov.dev/post/demystifying-the-kubernetes-iceberg-1" />
    <meta property="og:title" content="Demystifying the Kubernetes Iceberg: Part 1" />
    <meta property="og:description" content="Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This article explains all the concepts listed in the "Kubernetes Iceberg" meme from Reddit." />
    <meta property="og:image" content="https://github.com/asankov/asankov.github.io/blob/main/preview.png?raw=true" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://asankov.dev/post/demystifying-the-kubernetes-iceberg-1" />
    <meta property="twitter:title" content="Demystifying the Kubernetes Iceberg: Part 1" />
    <meta property="twitter:description" content="Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This article explains all the concepts listed in the "Kubernetes Iceberg" meme from Reddit." />
    <meta property="twitter:image" content="https://github.com/asankov/asankov.github.io/blob/main/preview.png?raw=true" />

    <link rel="stylesheet" href="/index.css">
    <script type="module" crossorigin src="/assets/index-xxxxxxxx.js"></script> <!-- Placeholder for Vite's main JS bundle -->
</head>
<body>
    <div id="root"></div>
    <script>
        // Store pre-rendered content for client-side hydration
        window.__PRELOADED_STATE__ = {
            post: {
                slug: "demystifying-the-kubernetes-iceberg-1",
                title: "Demystifying the Kubernetes Iceberg: Part 1",
                description: "Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This article explains all the concepts listed in the "Kubernetes Iceberg" meme from Reddit.",
                date: "2022-05-15T00:00:00.000Z",
                content: "<p>A while ago, <a href=\"https://www.reddit.com/user/dshurupov/\">u/dshurupov</a> <a href=\"https://www.reddit.com/r/kubernetes/comments/u9b95u/kubernetes_iceberg_the_bigger_picture_of_what_you/\">published a picture on Reddit</a> that I called &quot;The Kubernetes Iceberg.&quot;\nThe picture was made by the folks in <a href=\"https://flant.com/\">Flant</a>.</p>\n<p>It represents a vast iceberg, where on the top you have some of the simplest concepts of Kubernetes, and as you go below and underwater, you dive deeper into more advanced Kubernetes subjects.\nThis is the picture:</p>\n<p><img src=\"/images/kubernetes-iceberg.png\" alt=\"The Kubernetes Iceberg meme\"></p>\n<p>When I saw it, I thought it was brilliant.\nKubernetes is not easy to start with, and it is precisely like an iceberg.\nThe more you learn, the more you realize you have even more to learn.</p>\n<p>In this series of articles, I aim to go over each of the concepts present in the iceberg and explain them in the simplest way possible.\nSince the explanations will not be exhaustive, I will add additional links to my sources to continue the learning outside of my blog.</p>\n<p>The iceberg is quite vast, so I will split this into several articles, publishing one each week.</p>\n<p>This is the first article where I explain the first two levels of the iceberg.</p>\n<p><strong>NOTE:</strong> Even though I have been working with Kubernetes for almost three years at the time of this writing, I still don&#39;t consider myself a Kubernetes expert.\nIn fact, I was also not familiar with some of the more advanced concepts here, so I had to do some learning myself.\nAnd this is one of the reasons for writing this series of articles.\nSo that we can learn and grow together, both my readers and me.</p>\n<p>Strap on; it&#39;s going to be a fun ride!</p>\n<h2>Tier 1</h2>\n<h3>Docker</h3>\n<p><a href=\"https://www.docker.com/\">Docker</a> is a container runtime.\nIt was introduced to the world in a <a href=\"https://youtu.be/wW9CAH9nSLs\">lightning talk at PyCon US 2013</a>, previously being the backbone of a PaaS company called dotCloud.</p>\n<p>It revolutionized the way we build and deploy software, using age-old Linux concepts like <a href=\"https://man7.org/linux/man-pages/man7/cgroups.7.html\">cgroups</a> and <a href=\"https://man7.org/linux/man-pages/man7/namespaces.7.html\">namespaces</a>, but providing a friendly and easy-to-use interface on top of that.</p>\n<p>Nowadays, there is an open standard for container images and runtimes called <a href=\"https://opencontainers.org/\">OCI - Open Container Initiative</a>.\nDocker images are OCI-compatible, but the Docker runtime is not.\nOne of the compatible runtimes is <code>containerd</code>, which is also used by Docker under the hood.</p>\n<p><a href=\"https://containerd.io/\">Containerd</a> is a lower-level container runtime that can run OCI images (including ones built with Docker).</p>\n<p>Because Docker is not OCI-compatible, <a href=\"https://kubernetes.io/blog/2022/02/17/dockershim-faq/\">it is not supported as Kubernetes runtime anymore</a> (but Docker images ARE OCI-compatible, so you can still run them in Kubernetes).\nThis requires an additional component (called <code>dockershim</code>) to be the bridge between Docker and Kubernetes.\nThe Kubernetes community maintained this component, but they don&#39;t want to do that anymore since there are already many reliable OCI-compatible alternatives (<code>containerd</code> being one of them).</p>\n<h3>Pods</h3>\n<p><a href=\"https://kubernetes.io/docs/concepts/workloads/pods/\"><code>Pod</code></a> is a Kubernetes object that represents a workload.</p>\n<p>It is the smallest possible building block in Kubernetes.</p>\n<p>A pod can contain one or more containers.\nA pod should contain more than one container only if these containers are required to share memory and disk.</p>\n<p>Pods are ephemeral and disposable.\nA standalone Pod that dies or gets deleted won&#39;t be recreated, so your workload will just stop running if that happens.</p>\n<p>That is why we have...</p>\n<h3>Deployments</h3>\n<p><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\"><code>Deployment</code></a> is a Kubernetes object that represents a workload.</p>\n<p>It specifies an image and the number of desired replicas.\nKubernetes makes sure that the number of running replicas always matches the desired one.\nFor example, if we create a Deployment with three replicas, Kubernetes will create 3 Pods (one for each replica).\nIf any of the Pods gets deleted or dies, Kubernetes will spin up a new one to match the actual state of the cluster to the desired state.</p>\n<p>Automatic recreation of failed workloads is one of the best Kubernetes features and a big reason why Kubernetes is so popular nowadays.</p>\n<h3>kubectl run nginx â€”image=nginx</h3>\n<p><a href=\"https://kubernetes.io/docs/tasks/tools/#kubectl\"><code>kubectl</code></a> is a CLI for interacting with Kubernetes.\nYou can install it on your machine and use it to interact with every Kubernetes cluster.\nThe Kubernetes cluster you interact with and the way you interact with it (network location, API keys, certificates, etc.) is stored in a <a href=\"https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/\">kubeconfig</a> file.</p>\n<p>One of the commands of <code>kubectl</code> is <code>kubectl run</code>.\nThis command will create a Pod with the image specified by the <code>--image</code> flag.\nIn this case, the image is <code>nginx</code>, and the Pod name is also <code>nginx</code>.</p>\n<h2>Tier 2</h2>\n<h3>Secret</h3>\n<p><a href=\"https://kubernetes.io/docs/concepts/configuration/secret/\"><code>Secret</code></a> is a Kubernetes object for storing... well, secrets.\nOnce you create a <code>Secret</code>, the workloads running in your cluster can access that and use it.\nHowever, using the native <code>Secret</code> object is discouraged because <code>Secrets</code> in Kubernetes are not actually secret.\nKubernetes stores <code>Secret</code> values in plain text after base64 encoding them.\nThat means it&#39;s effortless for an attacker to steal them if they manage to hack inside your cluster.</p>\n<h3>Job</h3>\n<p><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/job/\"><code>Job</code></a> is a Kubernetes object representing a temporary workload that will run to complete a job and then exit.</p>\n<p>For example, you can have a <code>Job</code> that will start a <code>Pod</code> to do dome cleanup work.\nAfter the <code>Pod</code> finishes, it will exit and never start again (there are other types of Jobs, if this is what you want).</p>\n<h3>ConfigMap</h3>\n<p><a href=\"https://kubernetes.io/docs/concepts/configuration/configmap/\"><code>ConfigMap</code></a> is a Kubernetes object for storing configuration in the format of key-value pairs.\nOnce you create a <code>ConfigMap</code>, your can configure your workloads to use its values.</p>\n<h3>Service</h3>\n<p><a href=\"https://kubernetes.io/docs/concepts/services-networking/service/\"><code>Service</code></a> is a Kubernetes object that provides an abstraction point over a group of pods based on label selectors.</p>\n<p>When Pods are created in Kubernetes, each one of them is assigned an IP address. However, we said that Pods are ephemeral, and when one dies, it is never restarted. Instead, a new one is created, which means it gets a new IP address. This means that we cannot depend on Pods&#39; IP addresses because they can change without notice.</p>\n<p>This is where <code>Services</code> come in. A <code>Service</code> will wrap a group of <code>Pods</code> based on their labels. If a <code>Pod</code> dies, a new one will be created. The new one will have a new IP but the same labels, so the <code>Service</code> will pick it up and start sending traffic to it. That way, we have a stable interface to a shifting pool of workloads.</p>\n<h3>Ingress</h3>\n<p><code>Ingress</code> is a Kubernetes object that manages the external traffic coming into the cluster.</p>\n<p>An <code>Ingress</code> object can be configured to send traffic to different <code>Services</code> inside the cluster, based on path or hostname.</p>\n<p>The <code>Ingress</code> object is an abstract one. It only provides the configuration. The implementation of the ingress, e.g., the routing, is provided by additional components like the <a href=\"https://kubernetes.github.io/ingress-nginx/\">nginx ingress controller</a>. Kubernetes users are responsible for choosing the implementation and providing it (deploying the controllers).</p>\n<h2>Summary</h2>\n<p>This is all for part one.\nI hope you enjoyed it and learned something new.</p>\n<p>The series continues with <a href=\"/post/demystifying-the-kubernetes-iceberg-2/\">Part 2</a>.</p>\n<p>If you don&#39;t want to miss on more of my content, you can follow me on <a href=\"https://twitter.com/a_sankov\">Twitter</a> or <a href=\"https://www.linkedin.com/in/asankov/\">LinkedIn</a>.</p>\n"
            }
        };
    </script>
</body>
</html>
                