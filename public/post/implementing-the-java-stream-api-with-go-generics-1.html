
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Implementing the Java Stream API with Go Generics: Part 1</title>
    <meta name="description" content="The Java Stream API is a flexible API that allows you to use functional programming to manipulate data. Since Go 1.18 when generics were introduced to the language it is much easier to do something similar in Go. This port follows my experience implementing the Stream API in Go with generics." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://asankov.dev/post/implementing-the-java-stream-api-with-go-generics-1" />
    <meta property="og:title" content="Implementing the Java Stream API with Go Generics: Part 1" />
    <meta property="og:description" content="The Java Stream API is a flexible API that allows you to use functional programming to manipulate data. Since Go 1.18 when generics were introduced to the language it is much easier to do something similar in Go. This port follows my experience implementing the Stream API in Go with generics." />
    <meta property="og:image" content="https://github.com/asankov/asankov.github.io/blob/main/preview.png?raw=true" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://asankov.dev/post/implementing-the-java-stream-api-with-go-generics-1" />
    <meta property="twitter:title" content="Implementing the Java Stream API with Go Generics: Part 1" />
    <meta property="twitter:description" content="The Java Stream API is a flexible API that allows you to use functional programming to manipulate data. Since Go 1.18 when generics were introduced to the language it is much easier to do something similar in Go. This port follows my experience implementing the Stream API in Go with generics." />
    <meta property="twitter:image" content="https://github.com/asankov/asankov.github.io/blob/main/preview.png?raw=true" />

    <link rel="stylesheet" href="/index.css">
    <script type="module" crossorigin src="/assets/index-xxxxxxxx.js"></script> <!-- Placeholder for Vite's main JS bundle -->
</head>
<body>
    <div id="root"></div>
    <script>
        // Store pre-rendered content for client-side hydration
        window.__PRELOADED_STATE__ = {
            post: {
                slug: "implementing-the-java-stream-api-with-go-generics-1",
                title: "Implementing the Java Stream API with Go Generics: Part 1",
                description: "The Java Stream API is a flexible API that allows you to use functional programming to manipulate data. Since Go 1.18 when generics were introduced to the language it is much easier to do something similar in Go. This port follows my experience implementing the Stream API in Go with generics.",
                date: "2022-12-22T00:00:00.000Z",
                content: "<p>A long time ago in a galaxy far, far away...\nOkay, it was in the same galaxy, but a long time ago I used to be a Java developer.</p>\n<p>That is before I moved to working with Go full-time when I joined Docker in 2019.</p>\n<p>In my Java days, one of my favourite Java APIs was the Stream API.\nThis is a set of APIs that allow you to work with data structures such as lists in a way that resembles functional programming.</p>\n<p>For example, this code creates a new <code>Stream</code> with values of 1 to 5.\nIt then maps the values by multiplying each one by <code>2</code> and, in the end, calls the <code>System.out.println</code> method for each of the values.</p>\n<p>Running this code will print the values <code>2, 4, 6, 8, 10</code> to the screen.</p>\n<pre><code class=\"language-java\">Stream.of(1, 2, 3, 4, 5)\n    .map(i -&gt; i * 2)\n    .forEach(System.out::println)\n</code></pre>\n<p>This style of programming is loved by many (me included) for multiple reasons:</p>\n<ul>\n<li>it allows modifying data in an easy, human-readable manner</li>\n<li>it hides complex operations behind a simple API.\nWe can easily change the implementation without changing the code\n(for example, by calling the <code>parallel</code> method of the <code>Stream</code> object that converts the stream to a parallel one)</li>\n<li>it utilizes functional-programming patterns (like immutability and pure functions)</li>\n</ul>\n<p>Implementing such an API was not impossible in <a href=\"https://go.dev/blog/intro-generics\">Go before 1.18</a>, but because of the lack of generics, it would have meant that we needed to implement this API each time for each different type.\nNot ideal.</p>\n<p>Generics solve this problem, and it is precisely in use cases like this that their benefit is visible.</p>\n<p>So I decided that I am going to re-implement this API in Go.</p>\n<h2>Defining the interface</h2>\n<p>Before starting the implementation, I first had to define the interface.</p>\n<p>To do that, I copied the <code>Stream</code> interface from <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\">here</a> and used it as a baseline.</p>\n<p>Most of the rewriting of the interface from Java to Go was straightforward, but not everything.</p>\n<p>Of course, the Java and Go languages have some differences between them.\nThat meant that I had to make some minor changes to the interface for it to be usable in Go.</p>\n<p>These are the changes:</p>\n<h3>Function names capitalization</h3>\n<p>The most obvious one is that I had to capitalize all method names (<code>forEach</code> → <code>ForEach</code>, etc.).\nThat is because, in Go, all public identifiers start with a capital letter.\nDefining a private interface method makes no sense; hence I needed this change.</p>\n<h3>No function overloads in Go</h3>\n<p>Another change I had to make was renaming methods with the same name.\nIn the Java interface, there are methods like <code>sorted</code>, <code>collect</code>and <code>reduce</code> that have overloads based on the type and number of arguments they are invoked with.</p>\n<p>Go does not support function overloads, so I had to define these methods with different names.\nFull list of these name changes:</p>\n<ul>\n<li><code>reduce(BinaryOperator&lt;T&gt; accumulator)</code> → <code>Reduce</code></li>\n<li><code>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code> → <code>ReduceWithIdentity</code></li>\n<li><code>reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code>-&gt; <code>ReduceWithIdentityAndCombiner</code></li>\n<li><code>sorted()</code> → <code>Sorted</code></li>\n<li><code>sorted(Comparator&lt;? super T&gt; comparator)</code> → <code>SortedWithComparator</code></li>\n<li><code>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code> → <code>Collect</code></li>\n<li><code>collect(Collector&lt;? super T,A,R&gt; collector)</code> → <code>CollectWithCollector</code></li>\n</ul>\n<p>I have also decided to omit some methods from the Go interface.\nFor example, in Java, we have <code>(flat)mapToInt</code> and <code>(flat)mapToLong</code>, which return <code>IntStream/Int</code> and <code>LongStream/Long</code>.\nI have decided to keep only <code>(flat)mapToInt</code> which returns a stream of <code>int64</code> (or just an <code>int64</code>).\nGo does not have a type like <code>long</code>; instead, we use <code>int64</code>; hence the second method is not really needed.\n(I could have made <code>MapToInt(...) int32</code> and <code>MapToLong(...) int64</code>, but I think that is not needed unless you care that much about memory usage.</p>\n<p>Another difference is that the Java interface defines two <code>toArray</code> methods.\nOne that receives no arguments and returns an <code>Object[]</code> (hence erasing the original generic type), and one that receives an array generator and returns an array of the same type (hence saving the original generic type).\nThat is because Java generics are just compile-type checks, and all generic information is erased at runtime.\nThis is not the case in Go, and we do not need to receive an array generator to be able to preserve the original generic type.\nSo I have only defined one <code>ToArray</code> method that receives no arguments and returns a <code>T[]</code> (where <code>T</code> is the original generic type, hence preserving the original generic type).</p>\n<h3>Methods that cannot be part of the interface</h3>\n<p>Due to a limitation in the Go implementation of generics, some of the methods that are part of the Java <code>Stream</code> interface cannot be part of the Go interface.</p>\n<p>These methods are:</p>\n<ul>\n<li><code>map(Function&lt;? super T,? extends R&gt; mapper)</code></li>\n<li><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code></li>\n<li><code>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code></li>\n<li><code>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</code></li>\n<li><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></li>\n</ul>\n<p>The reason for that is these methods operator not only with the type of the Stream (<code>T</code>), but with one or two more generic types (<code>R</code>, <code>U</code>, <code>A</code>).\nGo does not allow attaching generic parameters to an interface methods, so something like this is not valid Go code:</p>\n<pre><code class=\"language-go\">type Stream[T any] interface {\n    Map[R any](mapper func(T) R) // ❌ compile-time error: interface method must have no type parameters\n}\n</code></pre>\n<p>This means that we cannot have these methods on the interface type.</p>\n<p>The solution I came up with is to extract these methods as package methods of the <code>stream</code> package and make the stream the first argument:</p>\n<pre><code class=\"language-go\">package stream\n\nfunc Map[T any, R any](stream Stream[T], mapper func(T) R) Stream[R]\n</code></pre>\n<p>This will allow us to implement the same functionality in a similar way, with the only drawback that in the implementation of <code>Map</code> (and the other functions in this group) we will not be able to use any of the internal of the current stream implementation, but would have to only use the interface methods.\nI think that should be ok.</p>\n<h3>Methods that cannot be implemented due to constraints</h3>\n<p>Generics in Go have something called a constraint.\nThat is the minimum type that can be passed to the generic function/struct.</p>\n<p>The most broad constraint is <code>any</code>, which is an alias for <code>interface{}</code>.\nThis constraint means that we can use every type with this generic function/struct, but it also limit what we can do with the value.</p>\n<p>For example, we can do:</p>\n<pre><code class=\"language-go\">func Do[T any](t T) T{\n    return t\n}\n</code></pre>\n<p>but we cannot do:</p>\n<pre><code class=\"language-go\">func Do[T any](t1, t2 T) T {\n     return t1 + t2 // ❌ compile-time error: invalid operation: operator + not defined on t1 (variable of type T constrained by any)\n}\n</code></pre>\n<p>that is because Go does not know whether the <code>+</code> operation will be defined on the type that we use with this generic function.</p>\n<p>If we want to be able to do something with the values we need to use more restrictive constraint.</p>\n<p>The Go package <a href=\"http://golang.org/x/exp/constraints\"><code>golang.org/x/exp/constraints</code></a> defines useful constraints like <code>Integer</code>, <code>Float</code>, etc.\nWe can use these if we want to do arithmetic operations with our values.</p>\n<p>We can use any interface as a constraint.</p>\n<p>As constraint for my <code>Stream</code> interface I picked <code>any</code> because I want to be used with as many types with possible.\nHowever, that means that some methods cannot be implemented.\nThese are the <code>Sorted()</code> method and <code>Distinct()</code> methods.\nIn Java they can be implemented for any type, because Java type inherits from <code>Object</code> and it has <code>equals</code> methods that can be used to compare the values.\nIn Go, that is simple not possible.\nThat is why, for my initial implementation I have left these methods non-implemented and if called they will <code>panic</code>.\nFor sorting there is the <code>SortedWithComparator</code> function that required the consumer pass a comparator, which will be used for the sorting.</p>\n<h3>Static methods</h3>\n<p>The Java <code>Stream</code> interface has some static methods attached to him.\nThese include <code>Stream.of</code> , <code>Stream.generate</code>, <code>Stream.iterate</code>, etc.\nGo does not have static methods, but does have package methods not attached to the type, so we can use that for these methods.\nThat way the usage of these methods in Java and Go will look similar:</p>\n<h3>No Optional</h3>\n<p>Since Java is notorious for its <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/NullPointerException.html\"><code>NullPointerException</code></a> in Java 8 the <code>Optional&lt;T&gt;</code> type was introduced.\nThis is a generic type that holds a value of type <code>T</code> OR <code>null</code> and it provides useful methods for working with the value.</p>\n<p>I decided not to implement this type and instead to work with raw Go pointers, because in Go not everything is a pointer and it&#39;s not that easy to get a nil-derefence error.</p>\n<p>All methods from the Java interface that return <code>Optional&lt;T&gt;</code> will return <code>*T</code> in my Go interface.</p>\n<pre><code class=\"language-java\">var s = Stream.of(1, 2, 3)\n</code></pre>\n<pre><code class=\"language-go\">import &quot;github.com/asankov/go-streams/stream&quot;\n\nvar s = stream.Of(1, 2, 3)\n</code></pre>\n<h2>Initial implementation</h2>\n<p>I wanted to make the initial implementation as simple as possible.</p>\n<p>I decided that the way to do that is to have a generic struct with a slice of generic elements.\nThese will be the elements of the stream.</p>\n<pre><code class=\"language-go\">type SliceStream[T any] struct {\n    elements []T\n}\n</code></pre>\n<p>The type constraint for the generic type <code>T</code> is <code>any</code> because we want to allow this struct to be used with any type (more on the limitation that comes from this decision later).</p>\n<p>The <code>elements</code> slice is a private property of the struct.\nWe do not want anyone to mess with the elements from the outside.\nInstead, we want the consumers of this struct to interact with it via the Stream API (also, the implementation can change later, and we can replace the slice with something different).</p>\n<p>Once we have the struct and interface defined, we can proceed to implement the methods.</p>\n<p>A lot of the methods were quite simple and don’t need any explanation.\nYou can see all the code <a href=\"https://github.com/asankov/go-streams\">here</a>.\nEach method is documented, and it also points to the Java alternative.</p>\n<p>Most of the methods like <code>ForEach</code>, <code>AnyMatch</code>, etc.\njust iterate over the slice of elements and do the respective action for each element.</p>\n<h2>Using the Stream</h2>\n<p>Now that we have the Stream implemented let&#39;s write some fancy code.</p>\n<p>We are going to implement the same example I wrote in Java in the beginning of this post.</p>\n<p>To constuct a stream use the <code>Of</code> or <code>OfSingle</code> methods of the <code>stream</code> package.\nThis will return an instance of <code>SliceStream</code> with the data we provided.\n(Since <code>SliceStream</code> is the only existent implementation of <code>Stream</code> so far, in the future these methods could return a different implementation.)</p>\n<pre><code class=\"language-go\">import &quot;github.com/asankov/go-streams/stream&quot;\n\ns := stream.Of(1, 2, 3, 4, 5)\n    Map(s, func(i int) int { return i * 2}).\n    ForEach(fmt.Println)\n</code></pre>\n<p>This code creates a <code>Stream</code> with the values <code>[1, 2, 3, 4, 5]</code>.</p>\n<p>In the then <code>Map</code>s each value by multiplying it by 2.\nThe values are now <code>[2, 4, 6, 8, 10]</code></p>\n<p>In the end, for each element of the stream it calls <code>fmt.Println</code>.</p>\n<p>After running this code, we are going to see this output in the console:</p>\n<pre><code class=\"language-console\">2\n4\n6\n8\n10\n</code></pre>\n<p>Of course, there are many more functions in the package, so you can download it and experiment with it.\nTo do so, run:</p>\n<pre><code class=\"language-console\">go get github.com/asankov/go-streams\n</code></pre>\n<p>and get started!</p>\n<h2>Unit-testing the code</h2>\n<p>Along with the first slice-based implementation I also wrote a unit-test suite that covers &gt;90% of the code.</p>\n<p>Most of the tests are in this <a href=\"https://github.com/asankov/go-streams/blob/main/stream/slice_stream_test.go\">file</a> with more test files in the same directory.</p>\n<h2>Leftovers and next steps</h2>\n<p>There are still some leftovers I would like to resolve at some point.</p>\n<h3>Lack of parallel operations</h3>\n<p>For example, right now the <code>Parallel</code> function of the <code>SliceStream</code> does not do anything, because the slice stream operations cannot be executed in parallel.\nThat is because, the slice is not a thread-safe data structure.\nIn order to implement thread-safe parallel operations I would need to use something like a channel to hold the data.\nThat should not be that hard and I plan to implement it in the near future.</p>\n<p>Non-parallel execution of the operations also means that the <code>combiner</code> function in <code>Collect</code> and <code>ReduceWithIdentityAndCombiner</code> is not used for anything.\nI also plan to correct that in the next implementation.</p>\n<h3>Missing Iterator and Spliterator</h3>\n<p>Also, I have not implemented the <code>Iterator</code> and <code>Spliterator</code> methods, because these including implementing additional data-structures.\nAgain, I plan to do that next.</p>\n<h3>Lack of terminal operations</h3>\n<p>In Java, a <code>Stream</code> can be read only once.\nIf you have a <code>Stream</code> and call a method like <code>forEach</code> it will do the operation you called <code>forEach</code> with and the <code>Stream</code> will be consumed.\nTrying to call <code>forEach</code> a second time will throw an Exception that the <code>Stream</code> has already been consumed.</p>\n<pre><code class=\"language-java\">var stream = Stream.of(1, 2, 3, 4, 5)\nstream.forEach(System.out::println) // this line will print all values to the console\n\nstream.forEach(System.out::println) // ❌ java.lang.IllegalStateException: stream has already been operated upon or closed\n</code></pre>\n<p>This is because <code>forEach</code> is something called terminal operation which consumes the <code>Stream</code>, which is no longer usable at that point.</p>\n<p>I have not added this in my implementation (so far).</p>\n<h3>Lack of lazy evaluation</h3>\n<p>Another really good thing about <code>Streams</code> is that the operations you perform are lazily-evaluated.</p>\n<p>That means that if you perform something like <code>Map</code> without actually consuming the value (for example with <code>ForEach</code> or <code>FindAny</code>) the Map operation will not be evaluated.\nIt will be evaluated only when we try to consume it.</p>\n<pre><code class=\"language-java\">var stream = Stream.of(1, 2, 3, 4, 5)\n\nstream = stream.map(i -&gt; i * 2) // this is not yet evaluated\n\nstream.forEach(System.out::println) // the map operation will only be evaluated once we get to here\n</code></pre>\n<p>This brings some performance benefits, because it means that if you accidentally forget to consume the stream all the operations you did with it before will be actually no-ops and won&#39;t waste any CPU time.</p>\n<p>This is another thing that is missing from my implementation.</p>\n<h2>Summary</h2>\n<p>Go 1.18 introduced a big change in the language <a href=\"https://go.dev/blog/intro-generics\">adding support for type-parameters</a>.</p>\n<p>This made it more easy to implement generic data-structures like Streams.</p>\n<p>Particularly for Stream, this does not feel like the most Go-like way of working with data.</p>\n<p>Indeed, functions are first-class citizens in Go and functional-like programming has always been possible in Go.\nBut they way functions are passed around in Go is much more verbose that the way to do it in Java:</p>\n<pre><code class=\"language-go\">s.Map(func(i int) string { return &quot;(&quot; + i + &quot;)&quot; })\n</code></pre>\n<p>is much more verbose and clunky than:</p>\n<pre><code class=\"language-java\">s.map(i -&gt; &quot;(&quot; + i + &quot;)&quot;)\n</code></pre>\n<p>because of the necessary <code>func</code> and <code>return</code> keyword, and need to specify both the arguments and return types (even though they can be inferred.)</p>\n<p>Even though, I had a good fun implementing this and finally did something practical with generics (which I was eager to come, having been used to them in my Java time) I don&#39;t think that such data structure will be used by many Go programmers (me included) because of the things listen above.</p>\n<p>Nevertheless, I still intent to fix all left-overs I outlined in the previous paragraph and have even more fun doing it, so stay tuned for Part 2.</p>\n<p>Until then, Merry Christmas and a Happy New Year! 🎅</p>\n<p>Enjoyed the post? If you don&#39;t want to miss the next one, you can follow me on <a href=\"https://twitter.com/a_sankov\">Twitter</a> or <a href=\"https://www.linkedin.com/in/asankov/\">LinkedIn</a>.</p>\n"
            }
        };
    </script>
</body>
</html>
                