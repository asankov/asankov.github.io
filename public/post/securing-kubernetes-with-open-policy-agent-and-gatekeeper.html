
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Securing Kubernetes with Open Policy Agent</title>
    <meta name="description" content="Build-in Kubernetes security is not enough for most organizations to enforce granular rules and policies to the workloads running in their clusters. That is why projects like OPA and Gatekeeper exist to help you achieve a higher level of Kubernetes security" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://asankov.dev/post/securing-kubernetes-with-open-policy-agent-and-gatekeeper" />
    <meta property="og:title" content="Securing Kubernetes with Open Policy Agent" />
    <meta property="og:description" content="Build-in Kubernetes security is not enough for most organizations to enforce granular rules and policies to the workloads running in their clusters. That is why projects like OPA and Gatekeeper exist to help you achieve a higher level of Kubernetes security" />
    <meta property="og:image" content="https://github.com/asankov/asankov.github.io/blob/main/preview.png?raw=true" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://asankov.dev/post/securing-kubernetes-with-open-policy-agent-and-gatekeeper" />
    <meta property="twitter:title" content="Securing Kubernetes with Open Policy Agent" />
    <meta property="twitter:description" content="Build-in Kubernetes security is not enough for most organizations to enforce granular rules and policies to the workloads running in their clusters. That is why projects like OPA and Gatekeeper exist to help you achieve a higher level of Kubernetes security" />
    <meta property="twitter:image" content="https://github.com/asankov/asankov.github.io/blob/main/preview.png?raw=true" />

    <link rel="stylesheet" href="/index.css">
    <script type="module" crossorigin src="/assets/index-xxxxxxxx.js"></script> <!-- Placeholder for Vite's main JS bundle -->
</head>
<body>
    <div id="root"></div>
    <script>
        // Store pre-rendered content for client-side hydration
        window.__PRELOADED_STATE__ = {
            post: {
                slug: "securing-kubernetes-with-open-policy-agent-and-gatekeeper",
                title: "Securing Kubernetes with Open Policy Agent",
                description: "Build-in Kubernetes security is not enough for most organizations to enforce granular rules and policies to the workloads running in their clusters. That is why projects like OPA and Gatekeeper exist to help you achieve a higher level of Kubernetes security",
                date: "2022-04-21T00:00:00.000Z",
                content: "<p>Over the past 8 years, Kubernetes became the de-facto standard for deploying and managing containerized applications.\nThis requires that the platform on which we build our apps (Kubernetes) be just as secure as our applications.</p>\n<p>Kubernetes gives you some security out-of-the-box and it also gives you methods for extending that yourself.\nLet&#39;s see what these are.</p>\n<h2>Build-in Kubernetes Security (RBAC)</h2>\n<p>What you get out of the box with Kubernetes is an <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\">RBAC (Role-Based Action Control)</a> mechanism, which allows you to define roles that can perform certain actions on the Kubernetes resources.\nFor example, you can define a <code>Developer</code> role that can <code>Get/List Deployments</code> and a <code>DevOps</code> role that can additionally <code>Create/Update Deployments</code>.</p>\n<h2>Why RBAC is not enough</h2>\n<p>Usually, that is not enough for most Kubernetes users.\nThe reason is that most organizations that use Kubernetes want to enforce more granular rules on their resources.\nFor example, they want to enforce that only images from trusted repositories are used as the base for Deployments, or that all workloads have proper resource limits.\nThis is not possible via RBAC.</p>\n<h2>Beyond RBAC</h2>\n<p>That is why Kubernetes has a pluggable mechanism for deploying additional validation for your resources.\nThese are called <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/\">validating webhooks</a> which allow you to register a webhook that will be called by Kubernetes to check whether a given resource can be created/updated.</p>\n<p>How this works is - you register a webhook that Kubernetes will call when objects are being interacted via (e.g. <code>CREATE</code> or <code>UPDATE</code> operation).\nKubernetes will send a request to the webhook, passing the object in the request body and it will expect to receive a response that should tell Kubernetes whether or not this resource should be created/updated.</p>\n<p>UPCOMING: An article that describes in more detail how validating webhooks work and how to write your own.</p>\n<p>You can write your own admission webhook from scratch or use <a href=\"https://github.com/open-policy-agent/gatekeeper\">Gatekeeper</a> which allows you to deploy custom policies, written in <a href=\"https://www.openpolicyagent.org/docs/latest/policy-language/\">Rego</a> and evaluated by <a href=\"https://www.openpolicyagent.org/\">Open Policy Agent</a>.</p>\n<h2>Open Policy Agent</h2>\n<p><a href=\"https://www.openpolicyagent.org/\">Open Policy Agent</a> is a general-purpose policy agent that evaluates JSON input against rules, written in Rego, and returns a JSON output based on the evaluation.</p>\n<h2>Rego</h2>\n<p>Rego is a declarative query language that can be used to write policies about the data coming into the system.</p>\n<p>A simple Rego rule that checks if the conference name of the input document is &quot;BSides&quot;:</p>\n<pre><code class=\"language-rego\">package bsides\n\ndefault allow = false\n\nallow = true {\n    input.conference.name = &quot;BSides&quot;\n}\n</code></pre>\n<p>If you want to play with the examples in the Rego playground, use the links in the <code>Link</code> column.</p>\n<table>\n<thead>\n<tr>\n<th>Input</th>\n<th>Output</th>\n<th>Playground link</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>{&quot;conference&quot;:{&quot;name&quot;: &quot;BSides&quot;}}</code></td>\n<td><code>{&quot;allow&quot;: true}</code></td>\n<td><a href=\"https://play.openpolicyagent.org/p/OqvsvG5BU7\">Link</a></td>\n</tr>\n<tr>\n<td><code>{&quot;conference&quot;:{&quot;name&quot;: &quot;SomethingElse&quot;}}</code></td>\n<td><code>{&quot;allow&quot;: false}</code></td>\n<td><a href=\"https://play.openpolicyagent.org/p/SzGf67ckQg\">Link</a></td>\n</tr>\n</tbody></table>\n<p>A bit more complex rule that checks if the conference name is &quot;BSides&quot; and the conference venue is &quot;UNWE&quot; and if not outputs a message:</p>\n<pre><code class=\"language-rego\">package bsides\n\nviolations[{&quot;msg&quot;: msg}] {\n    input.conference.name != &quot;BSides&quot;\n    input.conference.venue != &quot;UNWE&quot;\n    msg = sprintf(&quot;name and venue are wrong - [%s, %s]&quot;, [input.conference.name, input.conference.venue])\n}\n</code></pre>\n<p>However, the message is only shown if both checks are true, e.g. it will not output anything if only one of the values is wrong:</p>\n<table>\n<thead>\n<tr>\n<th>Input</th>\n<th>Output</th>\n<th>Correct</th>\n<th>Playground link</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>{&quot;conference&quot;:{&quot;name&quot;: &quot;BSides&quot;, &quot;venue&quot;: &quot;UNWE&quot;}}</code></td>\n<td><code>{&quot;violations&quot;: []}</code></td>\n<td>✅</td>\n<td><a href=\"https://play.openpolicyagent.org/p/wY3h6EN6Dj\">Link</a></td>\n</tr>\n<tr>\n<td><code>{&quot;conference&quot;:{&quot;name&quot;: &quot;SomethingElse&quot;, &quot;venue&quot;: &quot;SomethingElse&quot;}}</code></td>\n<td><code>{&quot;violations&quot;: [{&quot;msg&quot;: &quot;name and venue are wrong - [SomethingElse, SomethingElse]&quot;}]}</code></td>\n<td>✅</td>\n<td><a href=\"https://play.openpolicyagent.org/p/JeV5Yg2mlw\">Link</a></td>\n</tr>\n<tr>\n<td><code>{&quot;conference&quot;:{&quot;name&quot;: &quot;SomethingElse&quot;, &quot;venue&quot;: &quot;UNWE&quot;}}</code></td>\n<td><code>{&quot;violations&quot;: []}</code></td>\n<td>❌</td>\n<td><a href=\"https://play.openpolicyagent.org/p/ZPS6QPZZD7\">Link</a></td>\n</tr>\n<tr>\n<td><code>{&quot;conference&quot;:{&quot;name&quot;: &quot;BSides&quot;, &quot;venue&quot;: &quot;SomethingElse&quot;}}</code></td>\n<td><code>{&quot;violations&quot;: []}</code></td>\n<td>❌</td>\n<td><a href=\"https://play.openpolicyagent.org/p/Xo4jlfyFii\">Link</a></td>\n</tr>\n</tbody></table>\n<p>In this case, this is not what we want, we want to have an error message if at least one of the two values is wrong.</p>\n<p>However, Rego rules work by just chaining the expressions in an <code>AND</code> statement.</p>\n<p>That is why, if we want to achieve this result, we need to tweak the rule a bit:</p>\n<pre><code class=\"language-rego\">package bsides\n\nviolations[{&quot;msg&quot;: msg}] {\n    input.conference.name != &quot;BSides&quot;\n    msg := &quot;name is wrong&quot;\n}\n\nviolations[{&quot;msg&quot;: msg}] {\n    input.conference.venue != &quot;UNWE&quot;\n    msg := &quot;venue is wrong&quot;\n}\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>Input</th>\n<th>Output</th>\n<th>Correct</th>\n<th>Playground link</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>{&quot;conference&quot;:{&quot;name&quot;: &quot;BSides&quot;, &quot;venue&quot;: &quot;UNWE&quot;}}</code></td>\n<td><code>{&quot;violations&quot;: []}</code></td>\n<td>✅</td>\n<td><a href=\"https://play.openpolicyagent.org/p/WMxPOAnMqR\">Link</a></td>\n</tr>\n<tr>\n<td><code>{&quot;conference&quot;:{&quot;name&quot;: &quot;SomethingElse&quot;, venue: &quot;SomethingElse&quot;}}</code></td>\n<td><code>{&quot;violations&quot;: [{&quot;msg&quot;: &quot;name is wrong&quot;}, {&quot;msg&quot;: &quot;venue is wrong&quot;}]}</code></td>\n<td>✅</td>\n<td><a href=\"https://play.openpolicyagent.org/p/bOYYXRjkhY\">Link</a></td>\n</tr>\n<tr>\n<td><code>{&quot;conference&quot;:{&quot;name&quot;: &quot;SomethingElse&quot;, venue: &quot;UNWE&quot;}}</code></td>\n<td><code>{&quot;violations&quot;: [{&quot;msg&quot;: &quot;name is wrong&quot;}]}</code></td>\n<td>✅</td>\n<td><a href=\"https://play.openpolicyagent.org/p/iVHjvE6C4c\">Link</a></td>\n</tr>\n<tr>\n<td><code>{&quot;conference&quot;:{&quot;name&quot;: &quot;BSides&quot;, venue: &quot;SomethingElse&quot;}}</code></td>\n<td><code>{&quot;violations&quot;: [{&quot;msg&quot;: &quot;venue is wrong&quot;}]}</code></td>\n<td>✅</td>\n<td><a href=\"https://play.openpolicyagent.org/p/UB8NwmJ5e4\">Link</a></td>\n</tr>\n</tbody></table>\n<p>This covers rules all possibilities and we have at least one error message if some of the values are wrong.</p>\n<p><strong>NOTE:</strong> This is not a bug or a deficiency in Rego, this is just how Rego rules work and something we should be aware of when using the language.</p>\n<h2>Gatekeeper</h2>\n<p>As said, Open Policy Agent is a general-purpose policy engine that has nothing to do with Kubernetes.</p>\n<p>To use it with Kubernetes, we need an adapter that will be the bridge between OPA and Kubernetes.</p>\n<p>That adapter is called <a href=\"https://github.com/open-policy-agent/gatekeeper\">Gatekeeper</a>.\nIt serves as the bridge between Kubernetes and OPA.\nIt implements a Validating Webhook, allowing it to be called by Kubernetes to determine whether a resource can be created/updated.\nAlso, it provided the object data to the Rego policy so that when we are writing our policies we can expect to get the whole object data provided by Gatekeeper.</p>\n<p>It also allows storing the policies as Custom Kubernetes objects (CRDs).\nThat way, our policies, and rules become first-class citizens of our Kubernetes cluster.</p>\n<p>More about what CRDs are you can read here - <a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/\">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/</a>.</p>\n<h3>ConstraintTemplates</h3>\n<p><code>ConstraintTemplates</code> are Kubernetes objects - Custom Resource Definitions (CRDs) that are installed with Gatekeeper.</p>\n<p>They wrap a Rego policy and define input parameters for the policy.\nThis allows for a <code>ConstraintTemplates</code> to be reused with different parameters.</p>\n<p>A sample <code>ConstraintTemplate</code> looks like this:</p>\n<pre><code class=\"language-yaml\">apiVersion: templates.gatekeeper.sh/v1\nkind: ConstraintTemplate\nmetadata:\n  name: k8srequiredlabels\nspec:\n  crd:\n    spec:\n      names:\n        kind: K8sRequiredLabels\n      validation:\n        # Schema for the `parameters` field\n        openAPIV3Schema:\n          type: object\n          properties:\n            labels:\n              type: array\n              items:\n                type: string\n  targets:\n    - target: admission.k8s.gatekeeper.sh\n      rego: |\n        package k8srequiredlabels\n\n        violation[{&quot;msg&quot;: msg, &quot;details&quot;: {&quot;missing_labels&quot;: missing}}] {\n          provided := {label | input.review.object.metadata.labels[label]}\n          required := {label | label := input.parameters.labels[_]}\n          missing := required - provided\n          count(missing) &gt; 0\n          msg := sprintf(&quot;you must provide labels: %v&quot;, [missing])\n        }\n</code></pre>\n<p>This <code>ConstraintTemplate</code> wraps a Rego policy that checks whether a given Kubernetes resource has a set of required labels.</p>\n<p>The exact set is contained in the <code>input.parameters.labels</code> field.\nThe reason that we store the required labels in this parameter instead of hard-coding them into the policy is that this way we can reuse the <code>ConstraintTemplate</code> with another set of required labels.</p>\n<p>We will see where this parameter comes from soon.</p>\n<h3>Constraint</h3>\n<p>After you apply the <code>ConstraintTemplate</code> from above, Gatekeeper will register a new CRD into your cluster.</p>\n<p>The name of that CRD is in the <code>spec.crd.spec.names.kind</code> field of the <code>ConstraintTemplate</code>.\nIn our case, it&#39;s <code>K8sRequiredLabels</code>.</p>\n<p>To start enforcing this policy we will need to create an instance of this CRD, in which we will specify when to invoke the rule and what are the required labels.</p>\n<pre><code class=\"language-yaml\">apiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sRequiredLabels\nmetadata:\n  name: deployments-must-have-gk\nspec:\n  match:\n    kinds:\n      - apiGroups: [&quot;*&quot;]\n        kinds: [“Deployments&quot;]\n  parameters:\n    labels: [&quot;gatekeeper&quot;]\n</code></pre>\n<p>This resource specifies that this policy must be invoked when <code>Deployments</code> are being interacted with.</p>\n<p>It also specifies that the required labels are <code>[&quot;gatekeeper&quot;]</code>.</p>\n<p>Now, if we try to create a deployment, Gatekeeper will use OPA to check whether the deployment has the required labels.\nIf not, Gatekeeper will deny the creation of this resource, and Kubernetes will respect this decision, returning an error to the user.</p>\n<h3>Getting our hands dirty</h3>\n<p>Let&#39;s see all of this in practice.</p>\n<p><strong>NOTE:</strong> All of the resources I create below can be found in <a href=\"https://github.com/asankov/securing-kubernetes-with-open-policy-agent\">this GitHub repo</a>.\nTo follow the demo you can clone the repo and use the Kubernetes spec files or just reference them via their GitHub links.\nBoth ways are shown in the examples.</p>\n<h4>Installing Gatekeeper</h4>\n<p>First, we need to install Gatekeeper into our cluster.</p>\n<p>To do that apply this Kubernetes resource:</p>\n<pre><code class=\"language-sh\">kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/release-3.7/deploy/gatekeeper.yaml\n</code></pre>\n<p><strong>NOTE:</strong> This link is taken for the official docs at <a href=\"https://open-policy-agent.github.io/gatekeeper/website/docs/install/\">https://open-policy-agent.github.io/gatekeeper/website/docs/install/</a>.\nIf it gets outdated and it does not work, consult the actual docs.</p>\n<h4>Creating a ConstraintTemplates</h4>\n<p>Apply the <code>ConstraintTemplate</code> YAML:</p>\n<pre><code class=\"language-sh\">kubectl apply -f k8s/constraint-template.yaml\n</code></pre>\n<p>or if you haven&#39;t cloned the repo:</p>\n<pre><code class=\"language-sh\">kubectl apply -f https://raw.githubusercontent.com/asankov/securing-kubernetes-with-open-policy-agent/main/k8s/constraint-template.yaml\n</code></pre>\n<p>This should create the <code>ConstraintTemplate</code> and also register the <code>K8sRequiredLabels</code> CRD.</p>\n<p>Check that by running:</p>\n<pre><code class=\"language-sh\">$ kubectl get constrainttemplates.templates.gatekeeper.sh\nNAME                AGE\nk8srequiredlabels   119s\n</code></pre>\n<p>and</p>\n<pre><code class=\"language-sh\">$ kubectl get crds\nNAME                                                    CREATED AT\n...\nk8srequiredlabels.constraints.gatekeeper.sh             2022-04-09T20:49:22Z\n...\n</code></pre>\n<p>You should see the <code>k8srequiredlabels</code> constraint template and CRD in the output of these commands.</p>\n<h4>Creating a Constraint</h4>\n<p>To start enforcing this <code>ConstraintTemplate</code> create the actual <code>Constraint</code>:</p>\n<pre><code class=\"language-sh\">kubectl apply -f k8s/constraint.yaml\n</code></pre>\n<p>or if you haven&#39;t cloned the repo:</p>\n<pre><code class=\"language-sh\">kubectl apply -f https://raw.githubusercontent.com/asankov/securing-kubernetes-with-open-policy-agent/main/k8s/constraint.yaml\n</code></pre>\n<p>This should create the <code>K8sRequiredLabels</code> resource.</p>\n<p>Check that by running:</p>\n<pre><code class=\"language-sh\">$ kubectl get k8srequiredlabels.constraints.gatekeeper.sh\nNAME                       AGE\ndeployments-must-have-gk   8s\n</code></pre>\n<p>You should see the <code>deployments-must-have-gk</code> constraint output.</p>\n<h4>Creating a non-compliant resource</h4>\n<p>The moment of truth!\nWe have created our <code>ConstraintTemplate</code> and our <code>Constraint</code> so our security should be in place.\nLet&#39;s try to create a Deployment that does not comply with this rule and see what happens.</p>\n<pre><code class=\"language-sh\">kubectl apply -f k8s/non-compliant-deployment.yaml\n</code></pre>\n<p>or</p>\n<pre><code class=\"language-sh\">kubectl apply -f https://raw.githubusercontent.com/asankov/securing-kubernetes-with-open-policy-agent/main/k8s/non-compliant-deployment.yaml\n</code></pre>\n<p>In both cases the result should be:</p>\n<pre><code class=\"language-sh\">$ kubectl apply -f k8s/non-compliant-deployment.yaml\nError from server ([deployments-must-have-gk] you must provide labels: {&quot;gatekeeper&quot;}): error when creating &quot;non-compliant-deployment.yaml&quot;: admission webhook &quot;validation.gatekeeper.sh&quot; denied the request: [deployments-must-have-gk] you must provide labels: {&quot;gatekeeper&quot;}\n</code></pre>\n<p>Our deployment cannot be created, because it does not comply with our rule.</p>\n<p>What happened in more detail was:</p>\n<ul>\n<li>we invoked <code>kubectl</code> to try to create the deployment</li>\n<li><code>kubectl</code> parsed the <code>non-compliant-deployment.yaml</code> file, serialized it into JSON, and send a POST request to the Kube API server</li>\n<li>the Kube API server parsed the request</li>\n<li>it checked whether we have the necessary RBAC permission to perform this operation (we do)</li>\n<li>it called all validating webhooks registered for this type of operation (<code>action:CREATE</code>, <code>resource:Deployment</code>)</li>\n<li>one of these validating webhooks is <code>gatekeeper-validating-webhook-configuration</code> (the one coming from Gatekeeper)</li>\n<li>once Kubernetes called Gatekeeper, Gatekeeper checked what constraint it had for this operation (<code>action:CREATE</code>, <code>resource:Deployment</code>)</li>\n<li>the only and only constraint was <code>deployments-must-have-gk</code> (which has <code>k8srequiredlabels</code> for constraint template)</li>\n<li>Gatekeeper called OPA with the policy from <code>k8srequiredlabels</code> constraint template, passing as input the deployment being created and the parameters from the <code>deployments-must-have-gk</code> constraint</li>\n<li>OPA evaluated the policy and the input, giving as output <code>violations</code> array with one item</li>\n<li>Gatekeeper got the output from OPA, determined that this resource cannot be created, and returned a response to the Kube API server that this operation is not allowed</li>\n<li>the Kube API server aborted the operation and returned an error</li>\n<li><code>kubectl</code> outputs the error on the screen</li>\n</ul>\n<h4>Fixing the violation</h4>\n<p>The output is clear on where we are wrong and what we need to correct to create this resource.\nLet&#39;s do that.</p>\n<p>We have the same deployment with the additional labels in <a href=\"k8s/compliant-deployment.yaml\"><code>compliant-deployment.yaml</code></a>.</p>\n<p>Let&#39;s apply this file:</p>\n<pre><code class=\"language-sh\">kubectl apply -f k8s/compliant-deployment.yaml\n</code></pre>\n<p>or</p>\n<pre><code class=\"language-sh\">kubectl apply -f https://raw.githubusercontent.com/asankov/securing-kubernetes-with-open-policy-agent/main/k8s/compliant-deployment.yaml\n</code></pre>\n<p>In both cases the result should be:</p>\n<pre><code class=\"language-sh\">$ kubectl apply -f k8s/compliant-deployment.yaml\ndeployment.apps/non-compliant created\n</code></pre>\n<h2>Summary</h2>\n<p>Build-in Kubernetes security is not good enough for organizations that want to enforce granular policies on their resources.</p>\n<p>That is why Kubernetes has a pluggable mechanism for deploying additional validation for your resources.</p>\n<p>This gets even easier when you add Open Policy Agent and Gatekeeper.</p>\n<p>Gatekeeper provides all the plumbing, regarding the communication between Kubernetes and OPA. OPA provides a powerful policy agent that will evaluate your resources against rules written in the Rego language.</p>\n<p>If you liked this article, you can follow me on <a href=\"https://twitter.com/a_sankov\">Twitter</a> and <a href=\"https://www.linkedin.com/in/asankov/\">LinkedIn</a> for more content like this.</p>\n"
            }
        };
    </script>
</body>
</html>
                