
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Demystifying the Kubernetes Iceberg: Part 4</title>
    <meta name="description" content="Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This series of articles explains all the concepts listed in the "Kubernetes Iceberg" diagram by Flant." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://asankov.dev/post/demystifying-the-kubernetes-iceberg-4" />
    <meta property="og:title" content="Demystifying the Kubernetes Iceberg: Part 4" />
    <meta property="og:description" content="Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This series of articles explains all the concepts listed in the "Kubernetes Iceberg" diagram by Flant." />
    <meta property="og:image" content="https://github.com/asankov/asankov.github.io/blob/main/preview.png?raw=true" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://asankov.dev/post/demystifying-the-kubernetes-iceberg-4" />
    <meta property="twitter:title" content="Demystifying the Kubernetes Iceberg: Part 4" />
    <meta property="twitter:description" content="Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This series of articles explains all the concepts listed in the "Kubernetes Iceberg" diagram by Flant." />
    <meta property="twitter:image" content="https://github.com/asankov/asankov.github.io/blob/main/preview.png?raw=true" />

    <link rel="stylesheet" href="/index.css">
    <script type="module" crossorigin src="/assets/index-xxxxxxxx.js"></script> <!-- Placeholder for Vite's main JS bundle -->
</head>
<body>
    <div id="root"></div>
    <script>
        // Store pre-rendered content for client-side hydration
        window.__PRELOADED_STATE__ = {
            post: {
                slug: "demystifying-the-kubernetes-iceberg-4",
                title: "Demystifying the Kubernetes Iceberg: Part 4",
                description: "Kubernetes is like an iceberg. You learn the basics, only to see there is a lot more to learn. The more you learn, the more you see there is to know. This series of articles explains all the concepts listed in the "Kubernetes Iceberg" diagram by Flant.",
                date: "2022-06-05T00:00:00.000Z",
                content: "<p>This is the fourth article of the &quot;Demystifying the Kubernetes Iceberg&quot; series.\nMy goal for this series is to explain all concepts mentioned in the “Kubernetes Iceberg” diagram by <a href=\"https://flant.com/\">Flant</a>.</p>\n<p>This is the iceberg:</p>\n<p><img src=\"/images/kubernetes-iceberg.png\" alt=\"The Kubernetes Iceberg meme\"></p>\n<p>In this article, we will dive into Tier 5 of the iceberg.\nSince this tier is huge and would produce a really long article, I decided to split it in two parts.</p>\n<p>The first part (this article) will focus on all the security related concepts in this tier, the second one will focus on everything else.</p>\n<p>You can find the others article:</p>\n<ul>\n<li><a href=\"/post/demystifying-the-kubernetes-iceberg-1/\">Part 1</a></li>\n<li><a href=\"/post/demystifying-the-kubernetes-iceberg-2/\">Part 2</a></li>\n<li><a href=\"/post/demystifying-the-kubernetes-iceberg-3/\">Part 3</a></li>\n</ul>\n<p>I will publish one article each week until I complete the whole iceberg.</p>\n<h2>Tier 5, Part 1 - Security</h2>\n<h3>RBAC</h3>\n<p>RBAC stands for Role-Based Access Control.</p>\n<p>It is a way of doing authorization by having a set of Roles.\nEach Role is assigned a set of Permissions (ability to do something).\nEach user in the system is assigned a set of Roles.\nIn the end, the Roles a user has assigned govern how much they can do in the system.</p>\n<p>The permissions assigned to the roles contain a Kubernetes object and a verb.\nFor example, some Roles can be allowed to <code>List Deployment</code> but not to <code>Create Deployments</code> or <code>Update Deployments</code>.</p>\n<p>RBAC is the primary way for Kubernetes to do authorization.</p>\n<p>RBAC in Kubernetes can be configured dynamically through 4 API objects - <code>Role</code>, <code>ClusterRole</code>, <code>RoleBinding</code>, and <code>ClusterRoleBinding</code>.</p>\n<p>A sample RBAC scheme in an organization can look like this:</p>\n<table>\n<thead>\n<tr>\n<th>Role</th>\n<th>Get/List Deployments</th>\n<th>Create/Update Deployments</th>\n<th>Create RoleBinding</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Developer</td>\n<td>✅</td>\n<td>❌</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>DevOps</td>\n<td>✅</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Admin</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<p>A user with the <code>Developer</code> role can view the Deployments into the cluster, but they cannot edit them or create new ones.</p>\n<p>The <code>DevOps</code> role can not only view the Deployments but also create new ones and update existing ones.</p>\n<p>However, neither the <code>DevOps</code> nor the <code>Developer</code> can create new <code>RoleBindings</code> (which would mean assigning new roles to users, hence giving more permissions to some users).\nThis action can only be performed by the <code>Admin</code> group.</p>\n<p>You can read about RBAC in Kubernetes <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\">here</a>.</p>\n<p>RBAC is good because it gives you a lot of flexibility when assigning Roles and Permissions.\nHowever, RBAC alone may not be enough to protect your cluster.\nContinue reading for more advanced security techniques used in Kubernetes.</p>\n<h3>PodSecurityPolicy</h3>\n<p><code>PodSecurityPolicy</code> is a (deprecated) Kubernetes object that enabled (some sort of) fine-grained authorization of pod creation and updates.</p>\n<p>When creating a <code>PodSecurityPolicy</code>, you can specify some set of predefined rules that will be enforced for your Pod objects.</p>\n<p>For example, the following <code>PodSecurityPolicy</code> denies <code>Pods</code> that run privileged containers:</p>\n<pre><code class=\"language-yaml\">apiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: example\nspec:\n  privileged: false # Don&#39;t allow privileged pods!\n  # The rest fills in some required fields.\n  seLinux:\n    rule: RunAsAny\n  supplementalGroups:\n    rule: RunAsAny\n  runAsUser:\n    rule: RunAsAny\n  fsGroup:\n    rule: RunAsAny\n  volumes:\n    - &quot;*&quot;\n</code></pre>\n<p>When we try to create a Pod that defies this rule, we will get an error similar to this one:</p>\n<pre><code class=\"language-text\">Error from server (Forbidden): error when creating &quot;STDIN&quot;: pods &quot;privileged&quot; is forbidden: unable to validate against any pod security policy: [spec.containers[0].securityContext.privileged: Invalid value: true: Privileged containers are not allowed]\n</code></pre>\n<p>These rules are enforced by an admission controller that needs to be activated before we can create and enforce any <code>PodSecurityPolicies</code>.</p>\n<p>For the full spec of available rules, check out the <a href=\"https://kubernetes.io/docs/concepts/security/pod-security-policy/#what-is-a-pod-security-policy\">docs</a>.</p>\n<h4>Deprecation notice</h4>\n<p><code>PodSecurityPolicies</code> are deprecated since Kubernetes v1.21 and will be removed in v1.25.\nThose using <code>PodSecurityPolicies</code> should migrate to <code>[PodSecurityStandards](https://kubernetes.io/docs/concepts/security/pod-security-standards/)</code> which is a new and more flexible alternative to <code>PodSecurityPolicies</code></p>\n<h3>Audit logging</h3>\n<p>Audit logging is a special kind of logging that aims to show who accessed what in a system.\nAudit logs are treated very cautiously, usually outsourced to an external system, so that even if something fails with our application, the audit logs are saved and can be viewed.\nThis also prevents an attacker that got into our system from messing up with our audit logs and deleting its trails.</p>\n<p>Kubernetes provides audit logging functionality that logs every access to the given Kubernetes resources.\nOne could configure audit logging at a different level for the different kinds of resources.\nFor example, you could want to log absolutely everything when it comes to the critical resources but log less information when it comes to non-critical resources.</p>\n<p>Audit logging is configured via the <code>Policy</code> object in the <code>audit.k8s.io</code> APi group.</p>\n<p>For example, this <code>Policy</code> object configures the api server to log every request and response when it comes to interaction with <code>Pods</code> and to log nothing when it comes to interaction with the <code>&quot;controller-leader&quot;</code> <code>ConfigMap</code>:</p>\n<pre><code class=\"language-yaml\">apiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n  - level: RequestResponse\n    resources:\n      - group: &quot;&quot;\n        resources: [&quot;pods&quot;]\n  - level: None\n    resources:\n      - group: &quot;&quot;\n        resources: [&quot;configmaps&quot;]\n        resourceNames: [&quot;controller-leader&quot;]\n</code></pre>\n<h4>Audit logging backends</h4>\n<p>The Kube API server supports two audit logging backends.</p>\n<p>The first one is <strong>file</strong>-based.\nUsing it means that the API server will output all audit logs to a file.\nIt is configured via the <code>--audit-log-path</code> flag.</p>\n<p>The second supported backend is a <strong>webhooks</strong>-based one.\nUsing it means that the API server will call an external API to save the audit logs.\nIt is configured via the <code>--audit-webhook-config-file</code> flag.\nThe value of the flag should be the name of a kubeconfig file that specifies the location of the remote server and the credentials to access it.\nThe remote server should be a form of the Kubernetes API.</p>\n<h3>Image validation and signing</h3>\n<p>Signing container images means that the contents of a particular container image version are cryptographically signed, and they can be later verified.\nThis increases the trust in downloading container images from the internet because you have a way to verify that what you have downloaded is exactly what you expect.</p>\n<p>This can be done manually, but people often automate it and implement the workflow in their CI pipelines.</p>\n<p>The most popular project that enables this workflow is <a href=\"https://github.com/sigstore/cosign\">cosign</a>.</p>\n<h3>seccomp</h3>\n<p><a href=\"https://lwn.net/Articles/656307/\"><code>seccomp</code></a> (short for secure computing mode) is a Linux kernel utility that, when activated for a process, restricts the process to making any system calls (except <code>exit()</code>, <code>sigreturn()</code>, <code>read()</code>, and <code>write()</code> to already open file descriptors).</p>\n<p>Kubernetes supports enabling seccomp profiles to the containers running in the Pods.</p>\n<p>This is done via the <code>spec.securityContext.seccompProfile</code> in the Pod spec.</p>\n<p>There are different seccomp profiles that provide various levels of restriction.\nYou don&#39;t want to allow a container to do many syscalls, but you also don&#39;t want to obstruct the container from doing its job by restricting it from making the necessary syscalls.\nThat is why it&#39;s essential to craft your custom seccomp profiles that give a container permission to do only the syscalls that it is supposed to be doing.</p>\n<h3>AppArmor</h3>\n<p><a href=\"https://apparmor.net/\">AppArmor</a> is a Linux application security system.\nIt is deployed as a Kernel module, and most Linux distributions ship with AppArmor enabled.</p>\n<p>It is used by enabling certain profiles that protect your OS from known harmful and malicious behavior of applications.</p>\n<p>It is also integrated into Kubernetes.\nYou can enable it with kubelet flags and assign AppArmor profiles to containers via annotations.</p>\n<p>For example, creating a Pod with this annotation will enable the <code>runtime/default</code> AppArmor profile for the specified containers:</p>\n<pre><code class=\"language-yaml\">container.apparmor.security.beta.kubernetes.io/&lt;container_name&gt;: runtime/default\n</code></pre>\n<p>You can also register custom profiles.\nThis profile will enable file writes for all containers that have it assigned to them:</p>\n<pre><code class=\"language-c\">#include &lt;tunables/global&gt;\n\nprofile k8s-apparmor-example-deny-write flags=(attach_disconnected) {\n  #include &lt;abstractions/base&gt;\n\n  file,\n\n  # Deny all file writes.\n  deny /** w,\n}\n</code></pre>\n<p>You can assign it to a container via this annotation:</p>\n<pre><code class=\"language-yaml\">container.apparmor.security.beta.kubernetes.io/&lt;container_name&gt;: k8s-apparmor-example-deny-write\n</code></pre>\n<p>This is the same annotation as the previous one.\nWe just changed the profile name to match the name of our custom profile.</p>\n<p>If we create a container with this AppArmor profile and try to write to a file, we will get the following error:</p>\n<pre><code class=\"language-bash\">$ touch /tmp/test\ntouch: /tmp/test: Permission denied\nerror: error executing remote command: command terminated with non-zero exit code: Error executing in Docker Container: 1\n</code></pre>\n<p>AppArmor has been a Kubernetes feature since v1.4, but it&#39;s still in beta.\nThat is why it is configured via annotations and not first-class spec fields.</p>\n<h3>NetworkPolicy</h3>\n<p><code>NetworkPolicy</code> is a Kubernetes resource that controls the allowed ingress and egress traffic from and to a <code>Pod</code>.</p>\n<p><code>NetworkPolicy</code> is just a configuration resource.\nIt defines the allowed destinations but does not enforce anything.\nTo enforce the <code>NetworkPolicies</code>, you need to install a <a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/\">network plugin (also called CNI plugin)</a>.\nApplying a <code>NetworkPolicy</code> without installing a network plugin will have no effect.</p>\n<p>When creating a <code>NetworkPolicy</code>, you define all allowed <code>ingress</code> and <code>egress</code> destinations.\nThe network plugin will block every destination that is not in this allowlist.\n<code>NetworkPolicies</code> are additive.\nIf you have two network policies for the same Pod, the allowlist for this Pod is the sum of the allowlist of the two policies.\nTherefore, if you have an allow-all <code>NetworkPolicy</code> for a <code>Pod</code>, all other policies for this <code>Pod</code> will be useless.</p>\n<p>Here is an example policy applied to all pods with the label <code>role: db</code>.\nIt specifies that these Pods are allowed only ingress connections from pods with the label <code>role: frontend</code> and from the CIDR IP block <code>172.17.0.0/16</code> except for <code>172.17.1.0/24</code>:</p>\n<pre><code class=\"language-yaml\">apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: test-network-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      role: db\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - ipBlock:\n            cidr: 172.17.0.0/16\n            except:\n              - 172.17.1.0/24\n        - podSelector:\n            matchLabels:\n              role: frontend\n</code></pre>\n<h3>Mutating and Admission webhooks</h3>\n<p>Mutating and Admission webhooks are powerful instruments.\nAdmission webhooks allow you to implement dynamic admission control.\nMutating webhooks enable you to implement dynamic remediation of resources being created/updated.</p>\n<h4>Admission webhooks</h4>\n<p>Admission webhooks are webhooks that determine whether a create/update/delete operation for a resource should be allowed.</p>\n<p>They are called by the <code>ValidatingAdmissionWebhook</code> admission controller.\nSo although admission controllers themselves are not extendible, this particular admission controller allows you to deploy a webhook which will be called by Kubernetes, thus adding extensibility to the admission workflow.</p>\n<p>An admission webhook is just that, a webhook.\nIt expects a specific request and should return a proper response.\nIn between, you can implement whatever logic you want.\nThis way, you can have full control over what resources are deployed into your cluster.</p>\n<h4>Mutating webhooks</h4>\n<p>Mutating webhooks are webhooks that mutate a resource that is being applied to the API server.</p>\n<p>They are called by the <code>ValidatingAdmissionWebhook</code> admission controller.</p>\n<p>This can be useful to enforce a certain property of your resources.\nFor example, if you want to be sure that all your Pods will have their <code>spec.securityContext.runAsUser</code> field equal to <code>1000</code>, you can have a mutating webhook that will change this field to <code>1000</code> each time a <code>Pod</code> is applied.</p>\n<p>NOTE: This example will only work for <code>Pods</code> that are applied directly to the API server, it will not work for ones owned by <code>Deployments</code> or <code>ReplicaSets</code>, because the Deployment controller will be reconciling the Pods not stop and trying to set the field to its original value.\nIf you want to achieve that, you will need to create separate mutating webhook for <code>Deployments</code>, <code>ReplicaSets</code>, etc.</p>\n<h3>Dynamic Admission Control</h3>\n<p>By default, Kubernetes ships with so-called admission controllers.\nThese are controllers that control the interaction with the Kubernetes resources (create/update/delete, etc.).</p>\n<p>More specifically, they may block the creation/update/deletion of a given resource if that resource violates some rule according to the controller.</p>\n<p>These controllers are in-tree.\nTheir codebase lives together with the Kubernetes codebase.\nThey are compiled along with Kubernetes and called natively.\nIf you want to add an admission controller, you need to change the Kubernetes source code, rebuild it and deploy your custom Kubernetes version.</p>\n<p>Admission controllers can be enabled or disabled based on your preference.\nFor the complete list of available admission controllers, check the <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#experimenting-with-admission-webhooks\">docs</a>.</p>\n<h3>Open Policy Agent</h3>\n<p>Open Policy Agent or OPA is a general-purpose policy engine.\nIt evaluates JSON input against a set of Rego policies and returns a JSON output.</p>\n<p>A straightforward Rego policy:</p>\n<pre><code class=\"language-rego\">package kubernetes\n\ndefault allow = false\n\nallow = true {\n    input.author.name = &quot;Anton Sankov&quot;\n}\n</code></pre>\n<p>A simple JSON input:</p>\n<pre><code class=\"language-json\">{\n  &quot;author&quot;: {\n    &quot;name&quot;: &quot;Anton Sankov&quot;\n  }\n}\n</code></pre>\n<p>The output of this JSON input evaluated against this policy:</p>\n<pre><code class=\"language-json\">{\n  &quot;allow&quot;: true\n}\n</code></pre>\n<p>It is general-purpose; therefore, it can be used for absolutely everything.</p>\n<p>In the Kubernetes ecosystem, it is widely used for security, being the backbone of projects like Gatekeeper that provide customizable validating webhook.\nIn this case, the admission policies are written in Rego, and the Kubernetes object being evaluated is represented as JSON.</p>\n<h3>Bonus: Gatekeeper</h3>\n<p>The Gatekeeper project is not included in the iceberg, but I think it&#39;s an important part of the Kubernetes ecosystem and steps on some concepts explained here, so I will include it in the article nonetheless.</p>\n<p>Gatekeeper is a customizable admission webhooks.\nIt uses OPA under the hood and implement and admission webhook, so it can be used to implement dynamic admission control.</p>\n<p>Since it uses OPA, the policies are written in Rego.\nGatekeeper is responsible for registering the webhook that Kubernetes will call when someone interacts with the resources.\nThese resource will be then passed to the policy as arguments, so that you can make decisions based on the resource field.</p>\n<p>Policies are stored as CRD(Custom Resource Definition).\nThis CRD is also registered by Gatekeeper, to allow the users to interact with policies as first-class resources in a Kubernetes-native way.</p>\n<p>To register a simple policy that will be evaluated by Gatekeeper you need to create these two resources:</p>\n<p>First, a <code>ConstraintTemplate</code> that specifies the Rego policy and the expected arguments:</p>\n<pre><code class=\"language-yaml\">apiVersion: templates.gatekeeper.sh/v1\nkind: ConstraintTemplate\nmetadata:\n  name: k8srequiredlabels\nspec:\n  crd:\n    spec:\n      names:\n        kind: K8sRequiredLabels\n      validation:\n        # Schema for the `parameters` field\n        openAPIV3Schema:\n          type: object\n          properties:\n            labels:\n              type: array\n              items:\n                type: string\n  targets:\n    - target: admission.k8s.gatekeeper.sh\n      rego: |\n        package k8srequiredlabels\n\n        violation[{&quot;msg&quot;: msg, &quot;details&quot;: {&quot;missing_labels&quot;: missing}}] {\n          provided := {label | input.review.object.metadata.labels[label]}\n          required := {label | label := input.parameters.labels[_]}\n          missing := required - provided\n          count(missing) &gt; 0\n          msg := sprintf(&quot;you must provide labels: %v&quot;, [missing])\n        }\n</code></pre>\n<p>then an instance of the <code>ConstraintTemplate</code> (in this case <code>K8sRequiredLabels</code>) to tell Gatekeeper when to invoke this policy and with what arguments:</p>\n<pre><code class=\"language-yaml\">apiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sRequiredLabels\nmetadata:\n  name: deployments-must-have-gk\nspec:\n  match:\n    kinds:\n      - apiGroups: [&quot;*&quot;]\n        kinds: [“Deployments&quot;]\n  parameters:\n    labels: [&quot;gatekeeper&quot;]\n</code></pre>\n<p>If you want to learn more about using Gatekeeper and OPA check out my article about <a href=\"/post/securing-kubernetes-with-open-policy-agent/\">Securing Kubernetes with Open Policy Agent</a>.</p>\n<h3>OpenID Connect</h3>\n<p><a href=\"https://openid.net/connect/\">OpenID Connect</a> is a simple identity layer on top of the OAuth 2.0 protocol.\nIt allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner.</p>\n<h3>Dex</h3>\n<p><a href=\"https://dexidp.io/\">Dex</a> is an <a href=\"https://dexidp.io/\">OpenID Connect</a> provider.\nIt is an open-source project, currently a CNCF sandbox.</p>\n<p>It provides a single interface for multiple authentication providers.</p>\n<p>In the context of Kubernetes, Dex can be used as an authenticator plugin.\nThis means that users managed by other identity providers can automatically get some access to a Kubernetes cluster via Dex.</p>\n<p>This is useful for bigger organizations, where users are managed in a centralized place like Active Directory.\nAn adapter like Dex could enable users being added to a company&#39;s AD (or other IDP) to automatically get access to all the relevant Kubernetes clusters that their other team members also have access to.</p>\n<h3>Enterprise-level security</h3>\n<p>Enterprise-level security is a broad term and can mean a lot of things.\nEvery concept in this article can be part of an &quot;enterprise-level security.&quot;</p>\n<p>An enterprise using Kubernetes and wanting to secure it in an &quot;enterprise&quot; way needs to use at least half of the things described in this article.</p>\n<p>At a minimum, they need to use <a href=\"/post/demystifying-the-kubernetes-iceberg-4#RBAC\">RBAC</a> to ensure that everyone has access only to the resource they need to have.\nIdeally, that will be integrated with their AD provider using an <a href=\"/post/demystifying-the-kubernetes-iceberg-4/#openid-connect\">OpenID Connect</a> provider like <a href=\"/post/demystifying-the-kubernetes-iceberg-4/#dex\">Dex</a>.\nThen, they need to enable <a href=\"/post/demystifying-the-kubernetes-iceberg-4/#audit-logging\">audit logging</a> so that if someone manages to escalate privileges or if RBAC is configured wrong, there is a reliable trace for that.</p>\n<p>Another good additional layer of security would be to limit what processes the Pods can run via tools like <a href=\"/post/demystifying-the-kubernetes-iceberg-4/#apparmor\">AppArmor</a> and <a href=\"/post/demystifying-the-kubernetes-iceberg-4/#seccomp\">seccomp</a> and what network connections they can do via <a href=\"/post/demystifying-the-kubernetes-iceberg-4/#podsecuritypolicy\">PodSecurityPolicies</a>.</p>\n<p>Last but not least, they could implement Dynamic admission control via mutating and admission webhooks, using tools like <a href=\"blog/2022/06/05/demystifying-the-kubernetes-iceberg-4/#open-policy-agent\">OPA</a> and <a href=\"blog/2022/06/05/demystifying-the-kubernetes-iceberg-4/#gatekeeper\">Gatekeeper</a>.</p>\n<h2>Summary</h2>\n<p>This is all for part four.</p>\n<p>In this article, we managed to go over many of the main Kubernetes security concepts.\nSecurity is a really important topic in today&#39;s world and I believe that every Kubernetes practitioner should know at least a little bit of security.\nI hope that this article can be a good starting point of someone getting into Kubernetes security.</p>\n<p>The series continues with <a href=\"/post/demystifying-the-kubernetes-iceberg-5/\">Part 5</a>.</p>\n<p>If you don’t want to miss an article, you can follow me on <a href=\"https://twitter.com/a_sankov\">Twitter</a> or <a href=\"https://www.linkedin.com/in/asankov/\">LinkedIn</a>.</p>\n"
            }
        };
    </script>
</body>
</html>
                