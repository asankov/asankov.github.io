
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Different Ways to Initialize Go structs</title>
    <meta name="description" content="In this article, we'll take a look at what options Go is giving us to initialize our structs, what are their limitations and how to overcome them." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://asankov.dev/post/different-ways-to-initialize-go-structs" />
    <meta property="og:title" content="Different Ways to Initialize Go structs" />
    <meta property="og:description" content="In this article, we'll take a look at what options Go is giving us to initialize our structs, what are their limitations and how to overcome them." />
    <meta property="og:image" content="https://github.com/asankov/asankov.github.io/blob/main/preview.png?raw=true" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://asankov.dev/post/different-ways-to-initialize-go-structs" />
    <meta property="twitter:title" content="Different Ways to Initialize Go structs" />
    <meta property="twitter:description" content="In this article, we'll take a look at what options Go is giving us to initialize our structs, what are their limitations and how to overcome them." />
    <meta property="twitter:image" content="https://github.com/asankov/asankov.github.io/blob/main/preview.png?raw=true" />

    <link rel="stylesheet" href="/index.css">
    <script type="module" crossorigin src="/assets/index-xxxxxxxx.js"></script> <!-- Placeholder for Vite's main JS bundle -->
</head>
<body>
    <div id="root"></div>
    <script>
        // Store pre-rendered content for client-side hydration
        window.__PRELOADED_STATE__ = {
            post: {
                slug: "different-ways-to-initialize-go-structs",
                title: "Different Ways to Initialize Go structs",
                description: "In this article, we'll take a look at what options Go is giving us to initialize our structs, what are their limitations and how to overcome them.",
                date: "2022-01-29T00:00:00.000Z",
                content: "<p>Many languages like Java, C#, etc. have <code>constructors</code> that help you instantiate an object and its properties.</p>\n<p>Go does not have ‘constructors’ in the pure sense of the word.\nLet&#39;s see what Go has instead.</p>\n<h2>Build-in options</h2>\n<p>Out-of-the-box Go gives us 2 ways to initialize structs - struct literals and the <code>new</code> build-in function.\nLet’s see what these look like for a simple struct named <code>Person</code>:</p>\n<pre><code class=\"language-go\">package people\n\ntype Person struct {\n  age  int\n  name string\n}\n\n// struct literal\nperson := &amp;Person{\n  age:  25,\n  name: &quot;Anton&quot;,\n}\n\n// new build-in\nperson := new(Person) // person is of type *Person\nperson.age = 25\nperson.name = &quot;Anton&quot;\n</code></pre>\n<p>However, in this scenario the <code>Person</code> fields are un-exported, thus they cannot be used outside of the <code>people</code> package. We can easily mitigate this by exporting them:</p>\n<pre><code class=\"language-go\">// people/person.go\npackage people\n\ntype Person struct {\n  Name string\n  Age  int\n}\n\n// main.go\npackage main\n\nimport &quot;asankov.dev/people&quot;\n\n// struct literal\nperson := &amp;people.Person{\n  Name: &quot;Anton&quot;,\n  Age:  25,\n}\n\n// new build-in\nperson := new(people.Person) // p is of type *people.Person\nperson.Name = &quot;Anton&quot;\nperson.Age = 25\n</code></pre>\n<p>But both of these options contain a big trade-off - now all the fields of the person can be viewed and changed by anyone.\nAlso, we have no validation.\nFor example, in this scenario, we can easily set the <code>Age</code> property to a negative value.</p>\n<p>So what can we do if we don’t want to export the fields or enforce additional validation?</p>\n<h2>Constructor function</h2>\n<p>As I said in the beginning, Go does not have constructors.\nHowever, that does not mean we cannot define one ourselves.\nLet’s see how a user-defined constructor can look like:</p>\n<h3>With positional arguments</h3>\n<p>We can define a constructor function where the struct fields are positional arguments of the function:</p>\n<pre><code class=\"language-go\">package people\n\nfunc NewPerson(name string, age int) *Person {\n  if age &lt; 0 {\n    panic(&quot;NewPerson: age cannot be a negative number&quot;)\n  }\n  return &amp;Person{name: name, age: age}\n}\n</code></pre>\n<p>This provides us 2 benefits:</p>\n<ol>\n<li>We have validation for the <code>age</code> field. If someone tried to create a <code>Person</code> with a negative age, they will get a panic with a descriptive error of what they did wrong (we could have also returned an error, but this does not matter for the topic at hand). In the same manner, we could add validation for the <code>name</code> field (for example, that it’s not empty).</li>\n<li>The <code>Person</code> internals are decoupled from the initialization logic. For example, we can add an <code>isUnderage</code> field to the struct and compute that based on <code>age</code> inside of the <code>NewPerson</code> function. The consumer of the function won’t have to be bothered with the logic behind this field, because we are taking care of it.</li>\n</ol>\n<p>But it also has some downsides. If our <code>Person</code> had many <code>string</code> fields (for example - multiple names or addresses) this function would have looked like that:</p>\n<pre><code class=\"language-go\">func NewPerson(firstName, lastName, addressLine1, addressLine2 string, age int) *Person\n</code></pre>\n<p>and having a function with multiple parameters of the same type is a recipe for disaster.\nIn this case, the danger is that the consumer of this function can easily misplace any of the parameters (for example, replace the first and last names) and they would have no compile-time check for that.</p>\n<pre><code class=\"language-go\">// is it?\np := NewPerson(&quot;Anton&quot;, &quot;Sankov&quot;, &quot;Bulgaria&quot;, &quot;Sofia&quot;, 25)\n// or?\np := NewPerson(&quot;Anton&quot;, &quot;Sankov&quot;, &quot;Sofia&quot;, &quot;Bulgaria&quot;, 25)\n// or?\np := NewPerson(&quot;Anton&quot;, &quot;Bulgaria&quot;, &quot;Sofia&quot;, &quot;Sofia str, number 25&quot;, 25)\n</code></pre>\n<p>Another, even bigger issue than that is backward compatibility.\nLet’s say that we need to add additional fields to our <code>Person</code> struct. For example, <code>salary</code> (money rules the world, don’t they).\nWe can easily add it:</p>\n<pre><code class=\"language-go\">package people\n\ntype Person struct {\n  age    int\n  name   string\n  salary float64\n}\n\n// change\n// func NewPerson(name string, age int) *Person {\n// to:\nfunc NewPerson(name string, age int, salary float64) *Person {\n  if age &lt; 0 || salary &lt; 0 {\n    panic(&quot;NewPerson: age and salary cannot be negative numbers&quot;)\n  }\n  return &amp;Person{name: name, age: age, salary: salary}\n}\n</code></pre>\n<p>However, this is a breaking change to the <code>NewPerson</code> method. If this were a library, all of the consumers would get compilation errors when they upgrade to the new version. This is definitely not ideal and could have a side-effect of your consumers screaming at you on Twitter.</p>\n<p>Is there a way to make this without breaking change?\nYes, of course.\nTo do this we need to restructure our <code>NewPerson</code> function.\nLet’s see what are our options.</p>\n<h3>With Options struct</h3>\n<p>We can define <code>PersonOptions</code> struct that mirrors the <code>Person</code> but with exported field and pass this to <code>NewPerson</code>.\nLet’s see how this looks like:</p>\n<pre><code class=\"language-go\">package people\n\ntype Person struct {\n  age    int\n  name   string\n  salary float64\n}\n\ntype PersonOptions struct {\n  Age    int\n  Name   string\n  Salary float64\n}\n\nfunc NewPerson(opts *PersonOptions) *Person {\n  if opts == nil || opts.Age &lt; 0 || opts.Salary &lt; 0 {\n    panic(&quot;NewPerson: age and salary cannot be negative numbers&quot;)\n  }\n  return &amp;Person{name: opts.Name, age: opts.Age, salary: opts.Salary}\n}\n</code></pre>\n<p>This allows us to introduce new fields to <code>Person</code> as much as we like without breaking the contract of <code>NewPerson</code>.</p>\n<p>However, there is another trade-off here: If we add a new field to <code>Person</code>(and respectively <code>PersonOptions</code>) we cannot easily enforce that all consumers of <code>NewPerson</code> will set the new properties.</p>\n<p>Of course, we can fail <code>NewPerson</code> if any of the new fields are missing, but this is actually a breaking change, not much better than the one in the first example (and even worse, because it will only be caught at runtime).</p>\n<p>Another downside here is that it&#39;s not obvious which fields from the <code>PersonOptions</code> structs are required and which are optional.\nThe clearest way to communicate this to the consumers is via docstrings, which is not as obvious as just looking at the method signature (because who reads the docs, right).</p>\n<p>Possible mitigation to this problem is if we define the required field in <code>PersonOptions</code> as value types and the optional ones as refs.\nFor example:</p>\n<pre><code class=\"language-go\">type PersonOptions struct {\n  // Age and Name are required\n  Age    int\n  Name   string\n\n  // Salary is optional\n  Salary *float64\n}\n</code></pre>\n<p>This way the consumer can set the optional fields to <code>nil</code> and not bother with default values.\nIt is also a bit more clear what is required and what is not.</p>\n<h3>Variadic function constructor</h3>\n<p>Alternative to that is to make our constructor a variadic function that accepts an arbitrary number of mutating functions.\nThen, the implementation of the method will run all the functions one by one on an instance of the struct which will be returned by the constructor.\nThis means, we also need to provide a set of functions that will mutate the fields.</p>\n<p>If you did not understand anything from this explanation, don’t worry.\nHere’s how the code looks like:</p>\n<pre><code class=\"language-go\">package people\n\ntype PersonOptionFunc func(*Person)\n\nfunc WithName(name string) PersonOptionFunc {\n  return func(p *Person) {\n    p.name = name\n  }\n}\n\nfunc WithAge(age int) PersonOptionFunc {\n  return func(p *Person) {\n    p.age = age\n  }\n}\n\nfunc NewPerson(opts ...PersonOptionFunc) *Person {\n  p := &amp;Person{}\n  for _, opt := range opts {\n    opt(p)\n  }\n  return p\n}\n\n// usage:\np := people.NewPerson(people.WithName(&quot;Anton&quot;), people.WithAge(25))\n\nfmt.Println(p) // {name: &quot;Anton&quot;, age: 25}\n</code></pre>\n<p>The downside here is that the amount of <code>WithXXX</code> functions are not obvious, and the consumers of the package would either have to search them in the package documentation or depend on their IDE autocomplete to show them the possible options.</p>\n<p>In my opinion, it does not give you any benefits over the <code>Options</code> struct, but bring the downside that the options are not obvious.</p>\n<h3>Middle ground</h3>\n<p>A middle ground between constructor with required positional arguments and optional arguments would be to have the required fields for a given struct as positional arguments so that the consumer MUST pass them, and have everything else as optional parameters, which may be skipped.</p>\n<pre><code class=\"language-go\">func NewPerson(name string, options *PersonOptions) *Person {\n  p := &amp;Person{name: name}\n  if options == nil {\n    return p\n  }\n  if options.Age != 0 /* OR options.Age != nil */ {\n    p.age = options.Age /* OR p.age = *options.Age */\n  }\n  if options.Salary != 0 /* OR options.Salary != nil */  {\n    p.salary = options.Salary /* OR p.salary = *options.Salary */\n  }\n  return p\n}\n\n// usage:\np := NewPerson(&quot;Anton&quot;, &amp;people.PersonOptions{Age: 25})\n\nfmt.Println(p) // {name: &quot;Anton&quot;, age: 25}\n</code></pre>\n<h2>Summary</h2>\n<p>There are 2 build-in ways to initialize a Go struct.\nBoth are quite limited and more often than not they are not enough.\nThat is why people came up with more sophisticated solutions (based on the built-in ones).</p>\n<h2>Takeaways</h2>\n<p>So what is the best option?\nWell, there isn’t one.\nAll described approaches have their pros and cons.\nThey depend on your use case and the way your code is meant to be used.\nAs with everything in computer science, there is not a single correct solution or a silver bullet.\nIt’s all a matter of the tradeoffs you are willing to make.</p>\n<p>If you are writing a library that will be used by hundreds of other projects, backwards-incompatible changes will not be appreciated by your consumers, so you need to choose the more flexible options.\nIf you’re working locally in a single codebase, signature changes can be beneficial, because they will enforce that all usages of the methods are adapted.</p>\n<p>If you got to the end of the article, I just want you to know that I recently started this blog,\nand this is the first article in it.\nIf it was useful for you, you learned something new, or you think it can be improved feel free to ping me on <a href=\"https://twitter.com/a_sankov\">Twitter</a>, <a href=\"https://linkedin.com/in/asankov\">LinkedIn</a> or <a href=\"mailto:asankov96+initgo@gmail.com\">email</a>.\nI would appreciate the feedback.</p>\n"
            }
        };
    </script>
</body>
</html>
                